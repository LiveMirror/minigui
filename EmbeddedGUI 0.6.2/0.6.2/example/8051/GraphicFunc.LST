C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE GRAPHICFUNC
OBJECT MODULE PLACED IN GraphicFunc.OBJ
COMPILER INVOKED BY: E:\keil51\C51\BIN\C51.EXE GraphicFunc.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*
   2              EmbeddedGUI Library version 0.4.2
   3              Copyright (C) 2009  eluneyun WangChao
   4          
   5              This program is free software: you can redistribute it and/or modify
   6              it under the terms of the GNU Lesser General Public License as published by
   7              the Free Software Foundation ,either version 3 of the License, or
   8              (at your option) any later version.
   9          
  10              This program is distributed in the hope that it will be useful,
  11              but WITHOUT ANY WARRANTY; without even the implied warranty of
  12              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13              GNU Lesser General Public License for more details.
  14          
  15              You should have received a copy of the GNU Lesser General Public License
  16              along with this program.  If not, see <http://www.gnu.org/licenses/>.
  17          */
  18          /*
  19                  GraphicFunc.c
  20          */
  21          
  22          #include "GraphicFunc.h"
  23          
  24          #ifdef EG_SINGLE_COLOR
  25          
  26          #ifdef DOT_MATRIX_LCD
  27                  #include "LCDDriver.h"
  28          #endif  //DOT_MATRIX_LCD
  29          
  30          #ifdef WIN32_SIMULATE
                      #include "BufferDriver.h"
              #endif //WIN32_SIMULATE
  33          
  34          void EG_Graphic_DrawHorizonLine(unsigned int x,unsigned int y,unsigned int length){
  35   1          unsigned int n=0;
  36   1          for(;n<length;n++){
  37   2              EG_Graphic_DrawBlackPoint(x+n,y);
  38   2          }
  39   1      }
  40          
  41          void EG_Graphic_DrawVerticalLine(unsigned int x,unsigned int y,unsigned int length){
  42   1          unsigned int n=0;
  43   1          for(;n<length;n++){
  44   2              EG_Graphic_DrawBlackPoint(x,y+n);
  45   2          }
  46   1      }
  47          
  48          void EG_Graphic_DrawWhiteHorizonLine(unsigned int x,unsigned int y,unsigned int length){
  49   1          unsigned int n=0;
  50   1          for(;n<length;n++){
  51   2              EG_Graphic_DrawWhitePoint(x+n,y);
  52   2          }
  53   1      }
  54          
  55          void EG_Graphic_DrawWhiteVerticalLine(unsigned int x,unsigned int y,unsigned int length){
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 2   

  56   1          unsigned int n=0;
  57   1          for(;n<length;n++){
  58   2              EG_Graphic_DrawWhitePoint(x,y+n);
  59   2          }
  60   1      }
  61          
  62          void EG_Graphic_DrawLine(unsigned int x0,unsigned int y0,unsigned int x1,unsigned int y1,unsigned char vir
             -tualLine){
  63   1              int   dx;                                               //line x axie delta variable
  64   1              int   dy;                               // line y axie delta variable
  65   1              char    dx_sym;                                 // increase direaction of x axie    -1 or 1
  66   1              char    dy_sym;                                 // increase direaction of y axie 
  67   1              int   dx_x2;                                    //dx*2  accelarate variable
  68   1              int   dy_x2;                                    //dy*2  accelarate variable
  69   1              int   di;                                               //decide variable
  70   1              int count=0;
  71   1      
  72   1              dx = x1-x0;                                             //delta between two points.
  73   1              dy = y1-y0;
  74   1              /* whether this is a horizonal or vertical line  */
  75   1              if(dx>0){
  76   2                      dx_sym = 1;                                     // dx>0 , dx_sym=1
  77   2              }else{
  78   2                      if(dx<0){
  79   3                              dx_sym = (char)-1;                              //  dx<0 , dx_sym=-1
  80   3                      }else{  // dx==0  vertical line
  81   3                              EG_Graphic_DrawVerticalLine(x0, y0, y1-y0);
  82   3                              return;
  83   3                      }
  84   2              }
  85   1              if(dy>0){                                                       // direction of y axie
  86   2                      dy_sym = 1;                                     //dy>0,dy_sym=1
  87   2              }else{
  88   2                      if(dy<0){ 
  89   3                              dy_sym = (char)-1;                              //dy<0,dy_sym=-1
  90   3                      }else{  // dy==0, draw horizonal line
  91   3                              EG_Graphic_DrawHorizonLine(x0, y0, x1-x0);
  92   3                              return;
  93   3                      }
  94   2              }
  95   1              /*   abs( dx and dy )  */
  96   1              dx = dx_sym * dx;
  97   1              dy = dy_sym * dy;
  98   1              dx_x2 = dx*2;
  99   1              dy_x2 = dy*2;
 100   1      
 101   1              /* using Bresenham to draw straight line  */
 102   1              if(dx>=dy){                                             //dx>=dy  use x axie as direction.
 103   2                      di = dy_x2 - dx;
 104   2                      while(x0!=x1){
 105   3                              if (virtualLine){
 106   4                                      if (count==3){
 107   5                                              count=0;
 108   5                                      }else if(count==2){
 109   5                                              count=3;
 110   5                                      }else{
 111   5                                              count++;
 112   5                                              EG_Graphic_DrawBlackPoint(x0, y0);      
 113   5                                      }
 114   4                              }else{
 115   4                                      EG_Graphic_DrawBlackPoint(x0, y0);      
 116   4                              }
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 3   

 117   3                              x0 += dx_sym;
 118   3                              if(di<0){
 119   4                                      di += dy_x2;                    //dicision value of the next step
 120   4                              }else{
 121   4                                      di += dy_x2 - dx_x2;
 122   4                                      y0 += dy_sym;
 123   4                              }
 124   3                      }
 125   2                      EG_Graphic_DrawBlackPoint(x0, y0);      // show the last point
 126   2              }else{                                                          //dx<dy  use y axie as direction.
 127   2                  di = dx_x2 - dy;
 128   2                      while(y0!=y1){
 129   3                              if (virtualLine){
 130   4                                      if (count==3){
 131   5                                              count=0;
 132   5                                      }else if(count==2){
 133   5                                              count=3;
 134   5                                      }else{
 135   5                                              count++;
 136   5                                              EG_Graphic_DrawBlackPoint(x0, y0);      
 137   5                                      }
 138   4                              }else{
 139   4                                      EG_Graphic_DrawBlackPoint(x0, y0);      
 140   4                              }
 141   3                              y0 += dy_sym;
 142   3                              if(di<0){
 143   4                                      di += dx_x2;
 144   4                              }else{
 145   4                                      di += dx_x2 - dy_x2;
 146   4                                      x0 += dx_sym;
 147   4                              }
 148   3                      }
 149   2                      EG_Graphic_DrawBlackPoint(x0, y0);      
 150   2              } 
 151   1      }
 152          
 153          void EG_Graphic_DrawWidthLine(unsigned int x0,unsigned int y0,unsigned int x1,unsigned int y1,unsigned cha
             -r lineWidth){
 154   1              int   dx;                                               //delta value of x axie
 155   1              int   dy;                               //delta value of y axie
 156   1              char    dx_sym;                                 //increase direction along the x axie
 157   1              char    dy_sym;                                 //increase direction along the y axie
 158   1              int   dx_x2;                                    //equal to 2 * dx
 159   1              int   dy_x2;                                    //equal to 2 * dx
 160   1              int   di;                                               //decide variable
 161   1              int   wx, wy;                                   //line width
 162   1              int   draw_a, draw_b;
 163   1      
 164   1              //draw nothing, if width==0
 165   1              if(lineWidth==0)
 166   1                 return;
 167   1              //well, don't tell me width>50.....  if so, write a DrawStick function by yourself  :)
 168   1              if(lineWidth>50)
 169   1                      lineWidth = 50;
 170   1        
 171   1              dx = x1-x0;                     
 172   1              dy = y1-y0; 
 173   1              wx = lineWidth/2;
 174   1              wy = lineWidth-wx-1;
 175   1      
 176   1         /* set the increase direction along x axie*/
 177   1              if(dx>0){
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 4   

 178   2                      dx_sym = 1;                                     // dx>0, set dx_sym=1
 179   2              }else{
 180   2                      if(dx<0){
 181   3                              dx_sym = -1;                            // dx<0, set dx_sym=-1
 182   3                      }else{     /* dx==0,  it is a vertical line */
 183   3                              wx = x0-wx;
 184   3                              if(wx<0)
 185   3                                      wx = 0;
 186   3                              wy = x0+wy;
 187   3                              while(1){
 188   4                                      x0 = wx;
 189   4                                      EG_Graphic_DrawVerticalLine(x0, y0,y1-y0);
 190   4                                      if(wx>=wy)
 191   4                                              break;
 192   4                                      wx++;
 193   4                              }
 194   3                      return;
 195   3                      }
 196   2              }
 197   1         /* set the increase direction along x axie*/
 198   1              if(dy>0){
 199   2                      dy_sym = 1;                                     // dy>0, set dy_sym=1
 200   2              }else{
 201   2                      if(dy<0){
 202   3                              dy_sym = -1;                            // dy<0, set dy_sym=-1
 203   3                      }else{
 204   3                      /* dy==0  draw a horizonal line*/
 205   3                              wx = y0-wx;
 206   3                              if(wx<0)
 207   3                                      wx = 0;
 208   3                              wy = y0+wy;         
 209   3                              while(1){
 210   4                                      y0 = wx;
 211   4                                      EG_Graphic_DrawHorizonLine(x0, y0, x1-x0);
 212   4                                      if(wx>=wy)
 213   4                                              break;
 214   4                                      wx++;
 215   4                              }
 216   3                      return;
 217   3                      }
 218   2              }
 219   1              /*dx, dy = abs(dx,dy) */
 220   1              dx = dx_sym * dx;
 221   1              dy = dy_sym * dy;
 222   1              dx_x2 = dx*2;
 223   1              dy_x2 = dy*2;
 224   1         
 225   1              if(dx>=dy){
 226   2                      di = dy_x2 - dx;
 227   2                      while(x0!=x1){  
 228   3                              draw_a = y0-wx;
 229   3                              if(draw_a<0)
 230   3                                      draw_a = 0;
 231   3                              draw_b = y0+wy;
 232   3                              EG_Graphic_DrawVerticalLine(x0, draw_a, draw_b-draw_a);
 233   3                              x0 += dx_sym;                           
 234   3                              if(di<0){
 235   4                                      di += dy_x2;                    //get decide value of the next step
 236   4                              }else{
 237   4                                      di += dy_x2 - dx_x2;
 238   4                                      y0 += dy_sym;
 239   4                              }
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 5   

 240   3                      }
 241   2                      draw_a = y0-wx;
 242   2                      if(draw_a<0)
 243   2                              draw_a = 0;
 244   2                      draw_b = y0+wy;
 245   2                      EG_Graphic_DrawVerticalLine(x0,draw_a,draw_b-draw_a);
 246   2              }else{
 247   2                      di = dx_x2 - dy;
 248   2                      while(y0!=y1){  
 249   3                              draw_a =x0-wx;
 250   3                              if(draw_a<0)
 251   3                                      draw_a = 0;
 252   3                              draw_b = x0+wy;
 253   3                              EG_Graphic_DrawHorizonLine(draw_a, y0, draw_b-draw_a);         
 254   3                              y0 += dy_sym;
 255   3                              if(di<0){
 256   4                                      di += dx_x2;
 257   4                              }else{
 258   4                                      di += dx_x2 - dy_x2;
 259   4                                      x0 += dx_sym;
 260   4                              }
 261   3                      }
 262   2                      draw_a = x0-wx;
 263   2                      if(draw_a<0)
 264   2                              draw_a = 0;
 265   2                      draw_b = x0+wy;
 266   2                      EG_Graphic_DrawHorizonLine(draw_a, y0, draw_b-draw_a);
 267   2              }
 268   1      }
 269          
 270          void EG_Graphic_DrawEmptyRectangle(unsigned int x,unsigned int y,unsigned int height,unsigned int width){
 271   1          unsigned int n;     
 272   1          for (n=0;n<width;n++){
 273   2                      EG_Graphic_DrawVerticalLine(x,y,height);
 274   2                      EG_Graphic_DrawVerticalLine(x+width,y,height);
 275   2                      EG_Graphic_DrawHorizonLine(x,y,width);
 276   2                      EG_Graphic_DrawHorizonLine(x,y+height,width+1);         
 277   2              }
 278   1      }
 279          
 280          void EG_Graphic_DrawFilledRectangle(unsigned int x,unsigned int y,unsigned int height,unsigned int width){
 281   1          unsigned int n;     
 282   1          for (n=0;n<height;n++){
 283   2                      EG_Graphic_DrawHorizonLine(x,y+n,width);        
 284   2              }
 285   1      }
 286          
 287          void EG_Graphic_DrawWhiteFilledRectangle(unsigned int x,unsigned int y,unsigned int height,unsigned int wi
             -dth){
 288   1          unsigned int n;     
 289   1          for (n=0;n<height;n++){
 290   2                      EG_Graphic_DrawWhiteHorizonLine(x,y+n,width);   
 291   2              }
 292   1      }
 293          
 294          void EG_Graphic_DrawEmptyCircle(unsigned int x0,unsigned int y0,unsigned int r){
 295   1              int  draw_x0, draw_y0;                  //draw points
 296   1              int  draw_x1, draw_y1;  
 297   1              int  draw_x2, draw_y5;  
 298   1              int  draw_x3, draw_y3;  
 299   1              int  draw_x4, draw_y4;  
 300   1              int  draw_x6, draw_y6;  
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 6   

 301   1              int  draw_x7, draw_y7;  
 302   1              int draw_x5, draw_y2;   
 303   1              int  xx, yy;                                    // circle control variable
 304   1              int  di;                                                // decide variable
 305   1              if(0==r)
 306   1                      return;
 307   1      
 308   1              /* calculate 8 special point(0、45、90、135、180、225、270degree) display them */
 309   1              draw_x0 = draw_x1 = x0;
 310   1              draw_y0 = draw_y1 = y0 + r;
 311   1              if(draw_y0<63)
 312   1                      EG_Graphic_DrawBlackPoint(draw_x0,draw_y0);     // 90degree
 313   1              draw_x2 = draw_x3 = x0;
 314   1              draw_y2 = draw_y3 = y0 - r;
 315   1              if(draw_y2>=0)
 316   1                      EG_Graphic_DrawBlackPoint(draw_x2,draw_y2);// 270degree
 317   1              draw_x4 = draw_x6 = x0 + r;
 318   1              draw_y4 = draw_y6 = y0;
 319   1              if(draw_x4<127)
 320   1                      EG_Graphic_DrawBlackPoint(draw_x4, draw_y4);// 0degree
 321   1              draw_x5 = draw_x7 = x0 - r;
 322   1              draw_y5 = draw_y7 = y0;
 323   1              if(draw_x5>=0)
 324   1                      EG_Graphic_DrawBlackPoint(draw_x5, draw_y5);    // 180degree
 325   1              if(1==r)   // if the radius is 1, finished.
 326   1                      return;                                 
 327   1              /*using Bresenham */
 328   1              di = 3 - 2*r;   
 329   1              xx = 0;
 330   1              yy = r; 
 331   1              while(xx<yy){
 332   2                      if(di<0){
 333   3                              di += 4*xx + 6;       
 334   3                      }else{
 335   3                              di += 4*(xx - yy) + 10;
 336   3                              yy--;     
 337   3                              draw_y0--;
 338   3                              draw_y1--;
 339   3                              draw_y2++;
 340   3                              draw_y3++;
 341   3                              draw_x4--;
 342   3                              draw_x5++;
 343   3                              draw_x6--;
 344   3                              draw_x7++;              
 345   3                      }
 346   2                      xx++;   
 347   2                      draw_x0++;
 348   2                      draw_x1--;
 349   2                      draw_x2++;
 350   2                      draw_x3--;
 351   2                      draw_y4++;
 352   2                      draw_y5++;
 353   2                      draw_y6--;
 354   2                      draw_y7--;
 355   2                      /*judge current point in the avaible range*/
 356   2                      if( (draw_x0<=127)&&(draw_y0>=0) ){
 357   3                              EG_Graphic_DrawBlackPoint(draw_x0, draw_y0);
 358   3                      }           
 359   2                      if( (draw_x1>=0)&&(draw_y1>=0) ){
 360   3                              EG_Graphic_DrawBlackPoint(draw_x1, draw_y1);
 361   3                      }
 362   2                      if( (draw_x2<=127)&&(draw_y2<=63) ){
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 7   

 363   3                              EG_Graphic_DrawBlackPoint(draw_x2, draw_y2);
 364   3                      }
 365   2                      if( (draw_x3>=0)&&(draw_y3<=63) ){ 
 366   3                              EG_Graphic_DrawBlackPoint(draw_x3, draw_y3);
 367   3                      }
 368   2                      if( (draw_x4<=127)&&(draw_y4>=0) ){
 369   3                              EG_Graphic_DrawBlackPoint(draw_x4, draw_y4);
 370   3                      }
 371   2                      if( (draw_x5>=0)&&(draw_y5>=0) ){
 372   3                              EG_Graphic_DrawBlackPoint(draw_x5, draw_y5);
 373   3                      }
 374   2                      if( (draw_x6<=127)&&(draw_y6<=63) ){
 375   3                              EG_Graphic_DrawBlackPoint(draw_x6, draw_y6);
 376   3                      }
 377   2                      if( (draw_x7>=0)&&(draw_y7<=63) ){ 
 378   3                              EG_Graphic_DrawBlackPoint(draw_x7, draw_y7);
 379   3                      }
 380   2              }
 381   1      }
 382          
 383          void EG_Graphic_DrawFilledCircle(unsigned int x0,unsigned int y0,unsigned int r){
 384   1              int  draw_x0, draw_y0;          
 385   1              int  draw_x1, draw_y1;  
 386   1              int  draw_x2, draw_y2;  
 387   1              int  draw_x3, draw_y3;  
 388   1              int  draw_x4, draw_y4;  
 389   1              int  draw_x5, draw_y5;  
 390   1              int  draw_x6, draw_y6;  
 391   1              int  draw_x7, draw_y7;  
 392   1              int  fill_x0, fill_y0;          
 393   1              int  fill_x1;
 394   1              int  xx, yy;                            
 395   1              int  di;                                        
 396   1              if(0==r) return;
 397   1              draw_x0 = draw_x1 = x0;
 398   1              draw_y0 = draw_y1 = y0 + r;
 399   1              if(draw_y0<EG_ROW){
 400   2                      EG_Graphic_DrawBlackPoint(draw_x0, draw_y0);    
 401   2              }
 402   1              draw_x2 = draw_x3 = x0;
 403   1              draw_y2 = draw_y3 = y0 - r;
 404   1              if(draw_y2>=0){ 
 405   2                      EG_Graphic_DrawBlackPoint(draw_x2, draw_y2);
 406   2              }
 407   1              draw_x4 = draw_x6 = x0 + r;
 408   1              draw_y4 = draw_y6 = y0;
 409   1              if(draw_x4<EG_COLUMN){
 410   2                      EG_Graphic_DrawBlackPoint(draw_x4, draw_y4);    
 411   2                      fill_x1 = draw_x4;
 412   2              }else{
 413   2                      fill_x1 = EG_COLUMN;
 414   2              }
 415   1              fill_y0 = y0;                                           
 416   1              fill_x0 = x0 - r;                                       
 417   1              if(fill_x0<0)
 418   1                      fill_x0 = 0;
 419   1              EG_Graphic_DrawHorizonLine(fill_x0, fill_y0, fill_x1-fill_x0);
 420   1              draw_x5 = draw_x7 = x0 - r;
 421   1              draw_y5 = draw_y7 = y0;
 422   1              if(draw_x5>=0){
 423   2                      EG_Graphic_DrawBlackPoint(draw_x5, draw_y5);    
 424   2              }
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 8   

 425   1              if(1==r)
 426   1                      return;
 427   1              di = 3 - 2*r;                                           
 428   1              xx = 0;
 429   1              yy = r;
 430   1              while(xx<yy){
 431   2                      if(di<0){
 432   3                              di += 4*xx + 6;
 433   3                      }else{
 434   3                              di += 4*(xx - yy) + 10;
 435   3                              yy--;     
 436   3                              draw_y0--;
 437   3                              draw_y1--;
 438   3                              draw_y2++;
 439   3                              draw_y3++;
 440   3                              draw_x4--;
 441   3                              draw_x5++;
 442   3                              draw_x6--;
 443   3                              draw_x7++;               
 444   3                      }
 445   2                      xx++;   
 446   2                      draw_x0++;
 447   2                      draw_x1--;
 448   2                      draw_x2++;
 449   2                      draw_x3--;
 450   2                      draw_y4++;
 451   2                      draw_y5++;
 452   2                      draw_y6--;
 453   2                      draw_y7--;
 454   2                      if( (draw_x0<=EG_COLUMN)&&(draw_y0>=0) ){
 455   3                              EG_Graphic_DrawBlackPoint(draw_x0, draw_y0);
 456   3                      }           
 457   2                      if( (draw_x1>=0)&&(draw_y1>=0) ){
 458   3                              EG_Graphic_DrawBlackPoint(draw_x1, draw_y1);
 459   3                      }
 460   2                      if(draw_x1>=0){  
 461   3                              fill_x0 = draw_x1;
 462   3                              fill_y0 = draw_y1;
 463   3                              if(fill_y0>EG_ROW)
 464   3                                      fill_y0 = EG_ROW;
 465   3                              if(fill_y0<0)
 466   3                                      fill_y0 = 0; 
 467   3                              fill_x1 = x0*2 - draw_x1;                               
 468   3                              if(fill_x1>EG_COLUMN)
 469   3                                      fill_x1 = EG_COLUMN;
 470   3                              EG_Graphic_DrawHorizonLine(fill_x0, fill_y0, fill_x1-fill_x0);
 471   3                      }
 472   2                      if( (draw_x2<=EG_COLUMN)
 473   2                              &&(draw_y2<=EG_ROW) ){
 474   3                                      EG_Graphic_DrawBlackPoint(draw_x2, draw_y2);
 475   3                      }
 476   2                      if( (draw_x3>=0)&&(draw_y3<=EG_ROW) ){
 477   3                                      EG_Graphic_DrawBlackPoint(draw_x3, draw_y3);
 478   3                      }
 479   2                      if(draw_x3>=0){         
 480   3                              fill_x0 = draw_x3;     
 481   3                              fill_y0 = draw_y3;
 482   3                      if(fill_y0>EG_ROW)
 483   3                              fill_y0 = EG_ROW;
 484   3                      if(fill_y0<0)
 485   3                              fill_y0 = 0;
 486   3                      fill_x1 = x0*2 - draw_x3;               
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 9   

 487   3                      if(fill_x1>EG_COLUMN)
 488   3                              fill_x1 = EG_COLUMN;
 489   3                      EG_Graphic_DrawHorizonLine(fill_x0, fill_y0, fill_x1-fill_x0);
 490   3              }
 491   2              if( (draw_x4<=EG_COLUMN)&&(draw_y4>=0) ){
 492   3                      EG_Graphic_DrawBlackPoint(draw_x4, draw_y4);
 493   3              }
 494   2              if( (draw_x5>=0)&&(draw_y5>=0) ){
 495   3                      EG_Graphic_DrawBlackPoint(draw_x5, draw_y5);
 496   3              }
 497   2              if(draw_x5>=0)  {
 498   3                      fill_x0 = draw_x5;
 499   3                      fill_y0 = draw_y5;      
 500   3                      if(fill_y0>EG_ROW)
 501   3                              fill_y0 = EG_ROW;
 502   3                      if(fill_y0<0)
 503   3                              fill_y0 = 0;                                                    
 504   3                      fill_x1 = x0*2 - draw_x5;               
 505   3                      if(fill_x1>EG_COLUMN)
 506   3                              fill_x1 = EG_COLUMN;
 507   3                      EG_Graphic_DrawHorizonLine(fill_x0, fill_y0, fill_x1-fill_x0);
 508   3              }
 509   2              if( (draw_x6<=EG_COLUMN)&&(draw_y6<=EG_ROW) ){
 510   3                              EG_Graphic_DrawBlackPoint(draw_x6, draw_y6);
 511   3              }
 512   2              if( (draw_x7>=0)&&(draw_y7<=EG_ROW) ){
 513   3                      EG_Graphic_DrawBlackPoint(draw_x7, draw_y7);
 514   3              }
 515   2              if(draw_x7>=0)  {
 516   3                      fill_x0 = draw_x7;
 517   3                      fill_y0 = draw_y7;
 518   3                      if(fill_y0>EG_ROW)
 519   3                              fill_y0 = EG_ROW;
 520   3                      if(fill_y0<0)
 521   3                              fill_y0 = 0;    
 522   3                      fill_x1 = x0*2 - draw_x7;                       
 523   3                      if(fill_x1>EG_COLUMN)
 524   3                              fill_x1 = EG_COLUMN;
 525   3                      EG_Graphic_DrawHorizonLine(fill_x0, fill_y0, fill_x1-fill_x0);
 526   3              }
 527   2              }
 528   1      }
 529          
 530          void EG_Graphic_DrawWhiteFilledCircle(unsigned int x0,unsigned int y0,unsigned int r){
 531   1              int  draw_x0, draw_y0;          
 532   1              int  draw_x1, draw_y1;  
 533   1              int  draw_x2, draw_y2;  
 534   1              int  draw_x3, draw_y3;  
 535   1              int  draw_x4, draw_y4;  
 536   1              int  draw_x5, draw_y5;  
 537   1              int  draw_x6, draw_y6;  
 538   1              int  draw_x7, draw_y7;  
 539   1              int  fill_x0, fill_y0;          
 540   1              int  fill_x1;
 541   1              int  xx, yy;                            
 542   1              int  di;                                        
 543   1              if(0==r) return;
 544   1              draw_x0 = draw_x1 = x0;
 545   1              draw_y0 = draw_y1 = y0 + r;
 546   1              if(draw_y0<EG_ROW){
 547   2                      EG_Graphic_DrawWhitePoint(draw_x0, draw_y0);    
 548   2              }
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 10  

 549   1              draw_x2 = draw_x3 = x0;
 550   1              draw_y2 = draw_y3 = y0 - r;
 551   1              if(draw_y2>=0){ 
 552   2                      EG_Graphic_DrawWhitePoint(draw_x2, draw_y2);
 553   2              }
 554   1              draw_x4 = draw_x6 = x0 + r;
 555   1              draw_y4 = draw_y6 = y0;
 556   1              if(draw_x4<EG_COLUMN){
 557   2                      EG_Graphic_DrawWhitePoint(draw_x4, draw_y4);    
 558   2                      fill_x1 = draw_x4;
 559   2              }else{
 560   2                      fill_x1 = EG_COLUMN;
 561   2              }
 562   1              fill_y0 = y0;                                           
 563   1              fill_x0 = x0 - r;                                       
 564   1              if(fill_x0<0)
 565   1                      fill_x0 = 0;
 566   1              EG_Graphic_DrawWhiteHorizonLine(fill_x0, fill_y0, fill_x1-fill_x0);
 567   1              draw_x5 = draw_x7 = x0 - r;
 568   1              draw_y5 = draw_y7 = y0;
 569   1              if(draw_x5>=0){
 570   2                      EG_Graphic_DrawWhitePoint(draw_x5, draw_y5);    
 571   2              }
 572   1              if(1==r)
 573   1                      return;
 574   1              di = 3 - 2*r;                                           
 575   1              xx = 0;
 576   1              yy = r;
 577   1              while(xx<yy){
 578   2                      if(di<0){
 579   3                              di += 4*xx + 6;
 580   3                      }else{
 581   3                              di += 4*(xx - yy) + 10;
 582   3                              yy--;     
 583   3                              draw_y0--;
 584   3                              draw_y1--;
 585   3                              draw_y2++;
 586   3                              draw_y3++;
 587   3                              draw_x4--;
 588   3                              draw_x5++;
 589   3                              draw_x6--;
 590   3                              draw_x7++;               
 591   3                      }
 592   2                      xx++;   
 593   2                      draw_x0++;
 594   2                      draw_x1--;
 595   2                      draw_x2++;
 596   2                      draw_x3--;
 597   2                      draw_y4++;
 598   2                      draw_y5++;
 599   2                      draw_y6--;
 600   2                      draw_y7--;
 601   2                      if( (draw_x0<=EG_COLUMN)&&(draw_y0>=0) ){
 602   3                              EG_Graphic_DrawWhitePoint(draw_x0, draw_y0);
 603   3                      }           
 604   2                      if( (draw_x1>=0)&&(draw_y1>=0) ){
 605   3                              EG_Graphic_DrawWhitePoint(draw_x1, draw_y1);
 606   3                      }
 607   2                      if(draw_x1>=0){  
 608   3                              fill_x0 = draw_x1;
 609   3                              fill_y0 = draw_y1;
 610   3                              if(fill_y0>EG_ROW)
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 11  

 611   3                                      fill_y0 = EG_ROW;
 612   3                              if(fill_y0<0)
 613   3                                      fill_y0 = 0; 
 614   3                              fill_x1 = x0*2 - draw_x1;                               
 615   3                              if(fill_x1>EG_COLUMN)
 616   3                                      fill_x1 = EG_COLUMN;
 617   3                              EG_Graphic_DrawWhiteHorizonLine(fill_x0, fill_y0, fill_x1-fill_x0);
 618   3                      }
 619   2                      if( (draw_x2<=EG_COLUMN)&&(draw_y2<=EG_ROW) ){
 620   3                                      EG_Graphic_DrawWhitePoint(draw_x2, draw_y2);
 621   3                      }
 622   2                      if( (draw_x3>=0)&&(draw_y3<=EG_ROW) ){
 623   3                                      EG_Graphic_DrawWhitePoint(draw_x3, draw_y3);
 624   3                      }
 625   2                      if(draw_x3>=0){         
 626   3                              fill_x0 = draw_x3;     
 627   3                              fill_y0 = draw_y3;
 628   3                      if(fill_y0>EG_ROW)
 629   3                              fill_y0 = EG_ROW;
 630   3                      if(fill_y0<0)
 631   3                              fill_y0 = 0;
 632   3                      fill_x1 = x0*2 - draw_x3;               
 633   3                      if(fill_x1>EG_COLUMN)
 634   3                              fill_x1 = EG_COLUMN;
 635   3                      EG_Graphic_DrawWhiteHorizonLine(fill_x0, fill_y0, fill_x1-fill_x0);
 636   3              }
 637   2              if( (draw_x4<=EG_COLUMN)&&(draw_y4>=0) ){
 638   3                      EG_Graphic_DrawWhitePoint(draw_x4, draw_y4);
 639   3              }
 640   2              if( (draw_x5>=0)&&(draw_y5>=0) ){
 641   3                      EG_Graphic_DrawWhitePoint(draw_x5, draw_y5);
 642   3              }
 643   2              if(draw_x5>=0)  {
 644   3                      fill_x0 = draw_x5;
 645   3                      fill_y0 = draw_y5;      
 646   3                      if(fill_y0>EG_ROW)
 647   3                              fill_y0 = EG_ROW;
 648   3                      if(fill_y0<0)
 649   3                              fill_y0 = 0;                                                    
 650   3                      fill_x1 = x0*2 - draw_x5;               
 651   3                      if(fill_x1>EG_COLUMN)
 652   3                              fill_x1 = EG_COLUMN;
 653   3                      EG_Graphic_DrawWhiteHorizonLine(fill_x0, fill_y0, fill_x1-fill_x0);
 654   3              }
 655   2              if( (draw_x6<=EG_COLUMN)&&(draw_y6<=EG_ROW) ){
 656   3                              EG_Graphic_DrawWhitePoint(draw_x6, draw_y6);
 657   3              }
 658   2              if( (draw_x7>=0)&&(draw_y7<=EG_ROW) ){
 659   3                      EG_Graphic_DrawWhitePoint(draw_x7, draw_y7);
 660   3              }
 661   2              if(draw_x7>=0)  {
 662   3                      fill_x0 = draw_x7;
 663   3                      fill_y0 = draw_y7;
 664   3                      if(fill_y0>EG_ROW)
 665   3                              fill_y0 = EG_ROW;
 666   3                      if(fill_y0<0)
 667   3                              fill_y0 = 0;    
 668   3                      fill_x1 = x0*2 - draw_x7;                       
 669   3                      if(fill_x1>EG_COLUMN)
 670   3                              fill_x1 = EG_COLUMN;
 671   3                      EG_Graphic_DrawWhiteHorizonLine(fill_x0, fill_y0, fill_x1-fill_x0);
 672   3              }
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 12  

 673   2              }
 674   1      }
 675          
 676          void EG_Graphic_DrawQuarterArc(unsigned int x0,unsigned int y0,unsigned int r,unsigned char angle){
 677   1              int  draw_x, draw_y;
 678   1              int  op_x, op_y;
 679   1              int  op_2rr= 2*r*r;
 680   1      
 681   1              if(r==0)
 682   1                      return;
 683   1              switch(angle){
 684   2                      case  1:
 685   2                              draw_x = x0+r;
 686   2                              draw_y = y0;
 687   2                              op_x = r;
 688   2                              op_y = 0;
 689   2                              while(1){
 690   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);                               
 691   3                                      /*calculate the next point*/
 692   3                                      op_y++;
 693   3                                      draw_y++;
 694   3                                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
 695   4                                              op_x--;
 696   4                                              draw_x--;
 697   4                                      }
 698   3                                      if(op_y>=op_x)
 699   3                                              break;
 700   3                              }
 701   2                  while(1){
 702   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);                               
 703   3                                      /*calculate the next point*/
 704   3                                      op_x--;
 705   3                                      draw_x--;
 706   3                                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0){
 707   4                                              op_y++;
 708   4                                              draw_y++;
 709   4                                      }
 710   3                                      if(op_x<=0){ 
 711   4                                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);                               
 712   4                                              break;
 713   4                                      }
 714   3                              }
 715   2                  break;                              
 716   2                      case  2:
 717   2                              draw_x = x0-r;
 718   2                              draw_y = y0;
 719   2                              op_x = r;
 720   2                              op_y = 0;
 721   2                              while(1){               
 722   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);                               
 723   3                                      op_y++;
 724   3                                      draw_y++;
 725   3                                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
 726   4                                              draw_x++;
 727   4                                      }
 728   3                                      if(op_y>=op_x)
 729   3                                              break;
 730   3                              }
 731   2                              while(1){                               
 732   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);                               
 733   3                                      op_x--;
 734   3                                      draw_x++;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 13  

 735   3                                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0){
 736   4                                              op_y++;
 737   4                                              draw_y++;
 738   4                                      }
 739   3                                      if(op_x<=0){
 740   4                                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);                               
 741   4                                              break;
 742   4                                      }
 743   3                              }
 744   2                              break;
 745   2                      case  3:
 746   2                              draw_x = x0-r;
 747   2                              draw_y = y0;
 748   2                              op_x = r;
 749   2                              op_y = 0;
 750   2                              while(1){
 751   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);                               
 752   3                                      op_y++;
 753   3                                      draw_y--;
 754   3                                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
 755   4                                              op_x--;
 756   4                                              draw_x++;
 757   4                                      }
 758   3                                      if(op_y>=op_x)
 759   3                                              break;
 760   3                              }
 761   2                              while(1){
 762   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);                               
 763   3                                      op_x--;
 764   3                                      draw_x++;
 765   3                                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0){
 766   4                                              op_y++;
 767   4                                              draw_y--;
 768   4                                      }
 769   3                                      if(op_x<=0){                                    
 770   4                                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);                               
 771   4                                              break;
 772   4                                      }
 773   3                              }
 774   2                              break;
 775   2                      case  4:
 776   2                              draw_x = x0+r;
 777   2                              draw_y = y0;
 778   2                              op_x = r;
 779   2                              op_y = 0;
 780   2                              while(1){
 781   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);                               
 782   3                                      op_y++;
 783   3                                      draw_y--;
 784   3                                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
 785   4                                              op_x--;
 786   4                                              draw_x--;
 787   4                                      }
 788   3                                      if(op_y>=op_x)
 789   3                                              break;
 790   3                              }
 791   2                              while(1){
 792   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);                               
 793   3                                      op_x--;
 794   3                                      draw_x--;
 795   3                                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0){
 796   4                                              op_y++;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 14  

 797   4                                              draw_y--;
 798   4                                      }
 799   3                                      if(op_x<=0){
 800   4                                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);                               
 801   4                                              break;
 802   4                                      }
 803   3                              }
 804   2                              break;
 805   2                      default:
 806   2                              break;
 807   2              }
 808   1      }
 809          
 810          void EG_Graphic_DrawArc(unsigned int x0,unsigned int y0,unsigned int r,unsigned int startAngle,unsigned in
             -t endAngle){
 811   1              int  draw_x, draw_y;                                    //draw coordinate
 812   1              int  op_x, op_y;                                                //operation coordinate
 813   1              int  op_2rr=2*r*r;              
 814   1              int  pno_angle= 0;                              
 815   1              char  draw_on;                  //on=1,  draw point
 816   1      
 817   1              if(r==0)
 818   1                      return;                                 
 819   1              if(startAngle==endAngle)  //avoid the same angle,which may cause dead loop
 820   1                      return;                 
 821   1              if((startAngle>=360)|| (endAngle>=360))
 822   1                      return;
 823   1              /*arc points of 45 degree*/       
 824   1              op_x = r;
 825   1              op_y = 0;
 826   1              while(1){
 827   2                      pno_angle++;                                                    
 828   2                      /*calculate the next point*/
 829   2                      op_y++;
 830   2                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
 831   3                              op_x--;
 832   3                      }
 833   2                      if(op_y>=op_x) 
 834   2                              break;
 835   2              }
 836   1              draw_on = 0;                                                            //do not draw the point at the beginning
 837   1              /* set the start point */
 838   1              if(endAngle>startAngle)
 839   1                      draw_on = 1;
 840   1              startAngle = (360-startAngle)*pno_angle/45;
 841   1              endAngle = (360-endAngle)*pno_angle/45;
 842   1              if(startAngle==0)
 843   1                      startAngle=1;
 844   1              if(endAngle==0)
 845   1                      endAngle=1;
 846   1      
 847   1              /*draw the arc,clockwise rotation*/
 848   1              pno_angle = 0;
 849   1              draw_x = x0+r;
 850   1              draw_y = y0;         
 851   1              op_x = r;
 852   1              op_y = 0;
 853   1              while(1){ 
 854   2                      op_y++;
 855   2                      draw_y--;
 856   2                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
 857   3                              op_x--;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 15  

 858   3                              draw_x--;
 859   3                      }
 860   2                      if(draw_on==1) 
 861   2                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);
 862   2                      pno_angle++;
 863   2                      if((pno_angle==startAngle)||(pno_angle==endAngle)){
 864   3                              draw_on =1-draw_on;
 865   3                              if(draw_on==1)
 866   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
 867   3                      } 
 868   2                      if(op_y>=op_x){
 869   3                              if(draw_on==1) 
 870   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
 871   3                              break;
 872   3                      }
 873   2              }
 874   1              while(1){
 875   2                      op_x--;
 876   2                      draw_x--;
 877   2                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0){
 878   3                              op_y++;
 879   3                              draw_y--;
 880   3                      }
 881   2                      if(draw_on==1)
 882   2                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);
 883   2                      pno_angle++;
 884   2                      if((pno_angle==startAngle)||(pno_angle==endAngle)){                     //toggle the draw_on,if it is the start or end ang
             -le
 885   3                              draw_on = 1-draw_on;
 886   3                              if(draw_on==1)
 887   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
 888   3                      } 
 889   2                      if(op_x<=0){
 890   3                              if(draw_on==1) 
 891   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
 892   3                              break;
 893   3                      }
 894   2              }
 895   1              /*draw clockwise, from 269 degree*/
 896   1              draw_y = y0-r;
 897   1              draw_x = x0;         
 898   1              op_y = r;
 899   1              op_x = 0;
 900   1              while(1){
 901   2                      op_x++;
 902   2                      draw_x--;
 903   2                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_y +1)>0){
 904   3                              op_y--;
 905   3                              draw_y++;
 906   3                      }
 907   2                      if(draw_on==1)
 908   2                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);
 909   2                      pno_angle++;
 910   2                      if( (pno_angle==startAngle)||(pno_angle==endAngle)){
 911   3                              draw_on = 1-draw_on;
 912   3                              if(draw_on==1)
 913   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
 914   3                      }
 915   2                      if(op_x>=op_y){
 916   3                              if(draw_on==1)
 917   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
 918   3                      break;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 16  

 919   3                      }
 920   2              }
 921   1              while(1){
 922   2                      op_y--;
 923   2                      draw_y++;
 924   2                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_x +1)<=0){
 925   3                              op_x++;
 926   3                              draw_x--;
 927   3                      }
 928   2                      if(draw_on==1)
 929   2                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);
 930   2                      pno_angle++;
 931   2                      if((pno_angle==startAngle)||(pno_angle==endAngle)){
 932   3                              draw_on = 1-draw_on;
 933   3                              if(draw_on==1)
 934   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
 935   3                      }
 936   2                      if(op_y<=0){
 937   3                              if(draw_on==1)
 938   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
 939   3                              break;
 940   3                      }
 941   2              }
 942   1              /*draw clockwise, from 179 degree*/
 943   1              draw_x = x0-r;
 944   1              draw_y = y0;         
 945   1              op_x = r;
 946   1              op_y = 0;
 947   1              while(1){
 948   2                      op_y++;
 949   2                      draw_y++;
 950   2                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
 951   3                              op_x--;
 952   3                              draw_x++;
 953   3                      }
 954   2                      if(draw_on==1)
 955   2                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);
 956   2                      pno_angle++;
 957   2                      if((pno_angle==startAngle)||(pno_angle==endAngle)){
 958   3                              draw_on = 1-draw_on;
 959   3                              if(draw_on==1)
 960   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
 961   3                      } 
 962   2                      if(op_y>=op_x){
 963   3                              if(draw_on==1)
 964   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
 965   3                              break;
 966   3                      }
 967   2              }
 968   1              while(1){
 969   2                      op_x--;
 970   2                      draw_x++;
 971   2                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0){
 972   3                              op_y++;
 973   3                              draw_y++;
 974   3                      }
 975   2                      if(draw_on==1)
 976   2                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);
 977   2                      pno_angle++;
 978   2                      if((pno_angle==startAngle)||(pno_angle==endAngle)){
 979   3                              draw_on = 1-draw_on;
 980   3                              if(draw_on==1)
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 17  

 981   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
 982   3                      }
 983   2                      if(op_x<=0){
 984   3                              if(draw_on==1)
 985   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
 986   3                              break;
 987   3                      }
 988   2              }
 989   1              /*draw clockwise, from 89 degree*/
 990   1              draw_y = y0+r;
 991   1              draw_x = x0;         
 992   1              op_y = r;
 993   1              op_x = 0;
 994   1              while(1){
 995   2                      op_x++;
 996   2                      draw_x++;
 997   2                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_y +1)>0){
 998   3                              op_y--;
 999   3                              draw_y--;
1000   3                      }
1001   2                      if(draw_on==1)
1002   2                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1003   2                      pno_angle++;
1004   2                      if((pno_angle==startAngle)||(pno_angle==endAngle)){
1005   3                              draw_on = 1-draw_on;
1006   3                              if(draw_on==1)
1007   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1008   3                      }
1009   2                      if(op_x>=op_y){
1010   3                              if(draw_on==1)
1011   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1012   3                              break;
1013   3                      }
1014   2              }
1015   1              while(1){
1016   2                      op_y--;
1017   2                      draw_y--;
1018   2                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_x +1)<=0){
1019   3                              op_x++;
1020   3                              draw_x++;
1021   3                      }
1022   2                      if(draw_on==1)
1023   2                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1024   2                      pno_angle++;
1025   2                      if((pno_angle==startAngle)||(pno_angle==endAngle)){
1026   3                              draw_on = 1-draw_on;
1027   3                              if(draw_on==1)
1028   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1029   3                      } 
1030   2                      if(op_y<=0){
1031   3                              if(draw_on==1)
1032   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1033   3                              break;
1034   3                      }
1035   2              }
1036   1      }
1037          
1038          void EG_Graphic_DrawPieSlice(unsigned int x0,unsigned int y0,unsigned int r,unsigned int startAngle,unsign
             -ed int endAngle){
1039   1              int  draw_x, draw_y;                            //draw coordinate               
1040   1              int  op_x, op_y;                                        //operation coordinate
1041   1              int  op_2rr=2*r*r;                                      
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 18  

1042   1              int  pno_angle= 0;                                      
1043   1              unsigned char  draw_on;                                 //on=1,  draw point
1044   1      
1045   1              if(r==0)
1046   1                      return;                                         
1047   1              if(startAngle==endAngle) //avoid the same angle,which may cause dead loop
1048   1                      return;                 
1049   1              if((startAngle>=360) || (endAngle>=360))
1050   1                      return;
1051   1              /*arc points of 45 degree*/       
1052   1              op_x = r;
1053   1              op_y = 0;
1054   1              while(1){
1055   2                      pno_angle++;                                                    
1056   2                      /*calculate the next point*/
1057   2                      op_y++;
1058   2                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
1059   3                              op_x--;
1060   3                      }
1061   2                      if(op_y>=op_x) 
1062   2                              break;
1063   2              }
1064   1              draw_on = 0;                                                            //do not draw the point at the beginning
1065   1              /* set the start point */
1066   1              if(endAngle>startAngle)
1067   1                      draw_on = 1;
1068   1              startAngle = (360-startAngle)*pno_angle/45;
1069   1              endAngle = (360-endAngle)*pno_angle/45;
1070   1              if(startAngle==0)
1071   1                      startAngle=1;
1072   1              if(endAngle==0)
1073   1                      endAngle=1;
1074   1         
1075   1              /*draw the arc,clockwise rotation*/
1076   1              pno_angle = 0;
1077   1              draw_x = x0+r;
1078   1              draw_y = y0;         
1079   1              op_x = r;
1080   1              op_y = 0;
1081   1              while(1){ 
1082   2                      op_y++;
1083   2                      draw_y--;
1084   2                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
1085   3                              op_x--;
1086   3                              draw_x--;
1087   3                      }
1088   2                      if(draw_on==1) 
1089   2                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1090   2                      pno_angle++;
1091   2                      if((pno_angle==startAngle)||(pno_angle==endAngle)){
1092   3                              draw_on =1-draw_on;
1093   3                              if(draw_on==1)
1094   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1095   3                              EG_Graphic_DrawLine(x0,y0,draw_x,draw_y,0);
1096   3                      } 
1097   2                      if(op_y>=op_x){
1098   3                              if(draw_on==1) 
1099   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1100   3                              break;
1101   3                      }
1102   2              }   
1103   1              while(1){
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 19  

1104   2                      op_x--;
1105   2                      draw_x--;
1106   2                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0){
1107   3                              op_y++;
1108   3                              draw_y--;
1109   3                      }
1110   2                      if(draw_on==1)
1111   2                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1112   2                      pno_angle++;
1113   2                      if((pno_angle==startAngle)||(pno_angle==endAngle)){                     //toggle the draw_on,if it is the start or end ang
             -le
1114   3                              draw_on = 1-draw_on;
1115   3                              if(draw_on==1)
1116   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1117   3                              EG_Graphic_DrawLine(x0,y0,draw_x,draw_y,0);
1118   3                      } 
1119   2                      if(op_x<=0){
1120   3                              if(draw_on==1) 
1121   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1122   3                              break;
1123   3                      }
1124   2              }
1125   1              /*draw clockwise, from 269 degree*/
1126   1              draw_y = y0-r;
1127   1              draw_x = x0;         
1128   1              op_y = r;
1129   1              op_x = 0;
1130   1              while(1){
1131   2                      op_x++;
1132   2                      draw_x--;
1133   2                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_y +1)>0){
1134   3                              op_y--;
1135   3                              draw_y++;
1136   3                      }
1137   2                      if(draw_on==1)
1138   2                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1139   2                      pno_angle++;
1140   2                      if( (pno_angle==startAngle)||(pno_angle==endAngle)){
1141   3                              draw_on = 1-draw_on;
1142   3                              if(draw_on==1)
1143   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1144   3                              EG_Graphic_DrawLine(x0,y0,draw_x,draw_y,0);
1145   3                      }
1146   2                      if(op_x>=op_y){
1147   3                              if(draw_on==1)
1148   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1149   3                      break;
1150   3                      }
1151   2              }
1152   1              while(1){
1153   2                      op_y--;
1154   2                      draw_y++;
1155   2                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_x +1)<=0){
1156   3                              op_x++;
1157   3                              draw_x--;
1158   3                      }
1159   2                      if(draw_on==1)
1160   2                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1161   2                      pno_angle++;
1162   2                      if((pno_angle==startAngle)||(pno_angle==endAngle)){
1163   3                              draw_on = 1-draw_on;
1164   3                              if(draw_on==1)
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 20  

1165   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1166   3                              EG_Graphic_DrawLine(x0,y0,draw_x,draw_y,0);
1167   3                      }
1168   2                      if(op_y<=0){
1169   3                              if(draw_on==1)
1170   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1171   3                              break;
1172   3                      }
1173   2              }
1174   1              /*draw clockwise, from 179 degree*/
1175   1              draw_x = x0-r;
1176   1              draw_y = y0;         
1177   1              op_x = r;
1178   1              op_y = 0;
1179   1              while(1){
1180   2                      op_y++;
1181   2                      draw_y++;
1182   2                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
1183   3                              op_x--;
1184   3                              draw_x++;
1185   3                      }
1186   2                      if(draw_on==1)
1187   2                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1188   2                      pno_angle++;
1189   2                      if((pno_angle==startAngle)||(pno_angle==endAngle)){
1190   3                              draw_on = 1-draw_on;
1191   3                              if(draw_on==1)
1192   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1193   3                              EG_Graphic_DrawLine(x0,y0,draw_x,draw_y,0);
1194   3                      }
1195   2                      if(op_y>=op_x){
1196   3                              if(draw_on==1)
1197   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1198   3                              break;
1199   3                      }
1200   2              }
1201   1              while(1){
1202   2                      op_x--;
1203   2                      draw_x++;
1204   2                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0){
1205   3                              op_y++;
1206   3                              draw_y++;
1207   3                      }
1208   2                      if(draw_on==1)
1209   2                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1210   2                      pno_angle++;
1211   2                      if((pno_angle==startAngle)||(pno_angle==endAngle)){
1212   3                              draw_on = 1-draw_on;
1213   3                              if(draw_on==1)
1214   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1215   3                              EG_Graphic_DrawLine(x0,y0,draw_x,draw_y,0);
1216   3                      }
1217   2                      if(op_x<=0){
1218   3                              if(draw_on==1)
1219   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1220   3                              break;
1221   3                      }
1222   2              }
1223   1              /*draw clockwise, from 89 degree*/
1224   1              draw_y = y0+r;
1225   1              draw_x = x0;         
1226   1              op_y = r;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 21  

1227   1              op_x = 0;
1228   1              while(1){
1229   2                      op_x++;
1230   2                      draw_x++;
1231   2                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_y +1)>0){
1232   3                              op_y--;
1233   3                              draw_y--;
1234   3                      }
1235   2                      if(draw_on==1)
1236   2                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1237   2                      pno_angle++;
1238   2                      if((pno_angle==startAngle)||(pno_angle==endAngle)){
1239   3                              draw_on = 1-draw_on;
1240   3                              if(draw_on==1)
1241   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1242   3                              EG_Graphic_DrawLine(x0,y0,draw_x,draw_y,0);
1243   3                      }
1244   2                      if(op_x>=op_y){
1245   3                              if(draw_on==1)
1246   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1247   3                              break;
1248   3                      }
1249   2              }
1250   1              while(1){
1251   2                      op_y--;
1252   2                      draw_y--;
1253   2                      if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_x +1)<=0){
1254   3                              op_x++;
1255   3                              draw_x++;
1256   3                      }
1257   2                      if(draw_on==1)
1258   2                              EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1259   2                      pno_angle++;
1260   2                      if((pno_angle==startAngle)||(pno_angle==endAngle)){
1261   3                              draw_on = 1-draw_on;
1262   3                              if(draw_on==1)
1263   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1264   3                              EG_Graphic_DrawLine(x0,y0,draw_x,draw_y,0);
1265   3                      } 
1266   2                      if(op_y<=0){
1267   3                              if(draw_on==1)
1268   3                                      EG_Graphic_DrawBlackPoint(draw_x, draw_y);
1269   3                              break;
1270   3                      }
1271   2              }
1272   1      }
1273          
1274          void EG_Graphic_DrawEmptyEllipse(unsigned int leftX,unsigned int topY,unsigned int rightX,unsigned int bot
             -tomY){
1275   1              int  draw_x0, draw_y0;          
1276   1              int  draw_x1, draw_y1;
1277   1              int  draw_x2, draw_y2;
1278   1              int  draw_x3, draw_y3;
1279   1              int  xx, yy;                            // draw control variable 
1280   1              int  center_x, center_y;                //center of ellipse
1281   1              int  radius_x, radius_y;                // radius along x and y axies
1282   1              int  radius_xx, radius_yy;              
1283   1              int  radius_xx2, radius_yy2;
1284   1              int  di;                                                //decide variable
1285   1              
1286   1              if((leftX==rightX)||(topY==bottomY))
1287   1                      return;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 22  

1288   1              /*calculate the center of ellipse*/
1289   1              center_x = (leftX + rightX) >> 1;                       
1290   1              center_y = (topY + bottomY) >> 1;
1291   1              if(leftX > rightX){
1292   2                      radius_x = (leftX - rightX) >> 1;
1293   2              }else{
1294   2                      radius_x = (rightX - leftX) >> 1;
1295   2              }
1296   1              if(topY > bottomY){
1297   2                      radius_y = (topY - bottomY) >> 1;
1298   2              }else{
1299   2                      radius_y = (bottomY - topY) >> 1;
1300   2              }
1301   1              radius_xx = radius_x * radius_x;
1302   1              radius_yy = radius_y * radius_y;
1303   1              radius_xx2 = radius_xx<<1;
1304   1              radius_yy2 = radius_yy<<1;
1305   1              xx = 0;
1306   1              yy = radius_y;
1307   1              di = radius_yy2 + radius_xx - radius_xx2*radius_y ;
1308   1      
1309   1              /*calculate the end point of ellipse to start drawing*/
1310   1              draw_x0 = draw_x1 = draw_x2 = draw_x3 = center_x;
1311   1              draw_y0 = draw_y1 = center_y + radius_y;
1312   1              draw_y2 = draw_y3 = center_y - radius_y;
1313   1      
1314   1              //end point on y axie
1315   1              EG_Graphic_DrawBlackPoint(draw_x0,draw_y0);
1316   1              EG_Graphic_DrawBlackPoint(draw_x2,draw_y2);
1317   1              
1318   1              while((radius_yy*xx)<(radius_xx*yy)){
1319   2                      if(di<0){
1320   3                              di+= radius_yy2*(2*xx+3);
1321   3                      }else{
1322   3                              di += radius_yy2*(2*xx+3) + 4*radius_xx - 4*radius_xx*yy;
1323   3                              yy--;
1324   3                              draw_y0--;
1325   3                              draw_y1--;
1326   3                              draw_y2++;
1327   3                              draw_y3++;                               
1328   3                      }
1329   2                      xx ++;                                          // x axie ++
1330   2                      draw_x0++;
1331   2                      draw_x1--;
1332   2                      draw_x2++;
1333   2                      draw_x3--;
1334   2                      EG_Graphic_DrawBlackPoint(draw_x0,draw_y0);
1335   2                      EG_Graphic_DrawBlackPoint(draw_x1,draw_y1);
1336   2                      EG_Graphic_DrawBlackPoint(draw_x2,draw_y2);
1337   2                      EG_Graphic_DrawBlackPoint(draw_x3,draw_y3);
1338   2              }
1339   1              di = radius_xx2*(yy-1)*(yy-1) + radius_yy2*xx*xx + radius_yy + radius_yy2*xx - radius_xx2*radius_yy;
1340   1              while(yy>=0){
1341   2                      if(di<0){
1342   3                              di+= radius_xx2*3 + 4*radius_yy*xx + 4*radius_yy - 2*radius_xx2*yy;
1343   3                              xx ++;                                                  
1344   3                              draw_x0++;
1345   3                              draw_x1--;
1346   3                              draw_x2++;
1347   3                              draw_x3--;  
1348   3                      }else{
1349   3                              di += radius_xx2*3 - 2*radius_xx2*yy;                                                    
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 23  

1350   3                      }
1351   2                      yy--;
1352   2                      draw_y0--;
1353   2                      draw_y1--;
1354   2                      draw_y2++;
1355   2                      draw_y3++;      
1356   2                      EG_Graphic_DrawBlackPoint(draw_x0,draw_y0);
1357   2                      EG_Graphic_DrawBlackPoint(draw_x1,draw_y1);
1358   2                      EG_Graphic_DrawBlackPoint(draw_x2,draw_y2);
1359   2                      EG_Graphic_DrawBlackPoint(draw_x3,draw_y3);
1360   2              }
1361   1      }
1362          
1363          void EG_Graphic_DrawFilledEllipse(unsigned int leftX,unsigned int topY,unsigned int rightX,unsigned int bo
             -ttomY){
1364   1              int  draw_x0, draw_y0;          
1365   1              int  draw_x1, draw_y1;
1366   1              int  draw_x2, draw_y2;
1367   1              int  draw_x3, draw_y3;
1368   1              int  xx, yy;                            // draw control variable 
1369   1              int  center_x, center_y;                //center of ellipse
1370   1              int  radius_x, radius_y;                // radius along x and y axies
1371   1              int  radius_xx, radius_yy;              
1372   1              int  radius_xx2, radius_yy2;
1373   1              int  di;                                                //decide variable
1374   1              
1375   1              if((leftX==rightX)||(topY==bottomY))
1376   1                      return;
1377   1              /*calculate the center of ellipse*/
1378   1              center_x = (leftX + rightX) >> 1;                       
1379   1              center_y = (topY + bottomY) >> 1;
1380   1              if(leftX > rightX){
1381   2                      radius_x = (leftX - rightX) >> 1;
1382   2              }else{
1383   2                      radius_x = (rightX - leftX) >> 1;
1384   2              }
1385   1              if(topY > bottomY){
1386   2                      radius_y = (topY - bottomY) >> 1;
1387   2              }else{
1388   2                      radius_y = (bottomY - topY) >> 1;
1389   2              }
1390   1              radius_xx = radius_x * radius_x;
1391   1              radius_yy = radius_y * radius_y;
1392   1              radius_xx2 = radius_xx<<1;
1393   1              radius_yy2 = radius_yy<<1;
1394   1              xx = 0;
1395   1              yy = radius_y;
1396   1              di = radius_yy2 + radius_xx - radius_xx2*radius_y ;
1397   1      
1398   1              /*calculate the end point of ellipse to start drawing*/
1399   1              draw_x0 = draw_x1 = draw_x2 = draw_x3 = center_x;
1400   1              draw_y0 = draw_y1 = center_y + radius_y;
1401   1              draw_y2 = draw_y3 = center_y - radius_y;
1402   1      
1403   1              //end point on y axie
1404   1              EG_Graphic_DrawBlackPoint(draw_x0,draw_y0);
1405   1              EG_Graphic_DrawBlackPoint(draw_x2,draw_y2);
1406   1      
1407   1              while((radius_yy*xx)<(radius_xx*yy)){
1408   2                      if(di<0){
1409   3                              di+= radius_yy2*(2*xx+3);
1410   3                      }else{
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 24  

1411   3                              di += radius_yy2*(2*xx+3) + 4*radius_xx - 4*radius_xx*yy;
1412   3                              yy--;
1413   3                              draw_y0--;
1414   3                              draw_y1--;
1415   3                              draw_y2++;
1416   3                              draw_y3++;                               
1417   3                      }
1418   2                      xx ++;                                          // x axie ++
1419   2                      draw_x0++;
1420   2                      draw_x1--;
1421   2                      draw_x2++;
1422   2                      draw_x3--;
1423   2                      EG_Graphic_DrawBlackPoint(draw_x0,draw_y0);
1424   2                      EG_Graphic_DrawBlackPoint(draw_x1,draw_y1);
1425   2                      EG_Graphic_DrawBlackPoint(draw_x2,draw_y2);
1426   2                      EG_Graphic_DrawBlackPoint(draw_x3,draw_y3);
1427   2                      if(di>=0){
1428   3                              if(draw_x1>draw_x0)
1429   3                                      EG_Graphic_DrawHorizonLine(draw_x0, draw_y0, draw_x1-draw_x0);
1430   3                              else
1431   3                                      EG_Graphic_DrawHorizonLine(draw_x1, draw_y1, draw_x0-draw_x1);
1432   3                              if(draw_x3>draw_x2)
1433   3                                      EG_Graphic_DrawHorizonLine(draw_x2, draw_y2, draw_x3-draw_x2);
1434   3                              else
1435   3                                      EG_Graphic_DrawHorizonLine(draw_x3, draw_y3, draw_x2-draw_x3);
1436   3                      }
1437   2              }
1438   1              di = radius_xx2*(yy-1)*(yy-1) + radius_yy2*xx*xx + radius_yy + radius_yy2*xx - radius_xx2*radius_yy;
1439   1              while(yy>=0){
1440   2                      if(di<0){
1441   3                              di+= radius_xx2*3 + 4*radius_yy*xx + 4*radius_yy - 2*radius_xx2*yy;
1442   3                              xx ++;                                                  
1443   3                              draw_x0++;
1444   3                              draw_x1--;
1445   3                              draw_x2++;
1446   3                              draw_x3--;  
1447   3                      }else{
1448   3                              di += radius_xx2*3 - 2*radius_xx2*yy;                                                    
1449   3                      }
1450   2                      yy--;
1451   2                      draw_y0--;
1452   2                      draw_y1--;
1453   2                      draw_y2++;
1454   2                      draw_y3++;      
1455   2                      EG_Graphic_DrawBlackPoint(draw_x0,draw_y0);
1456   2                      EG_Graphic_DrawBlackPoint(draw_x1,draw_y1);
1457   2                      EG_Graphic_DrawBlackPoint(draw_x2,draw_y2);
1458   2                      EG_Graphic_DrawBlackPoint(draw_x3,draw_y3);
1459   2                      //fill it ,since y axie has already changed
1460   2                      if(draw_x1>draw_x0)
1461   2                              EG_Graphic_DrawHorizonLine(draw_x0, draw_y0, draw_x1-draw_x0);
1462   2                      else
1463   2                              EG_Graphic_DrawHorizonLine(draw_x1, draw_y1, draw_x0-draw_x1);
1464   2                      if(draw_x3>draw_x2)
1465   2                              EG_Graphic_DrawHorizonLine(draw_x2, draw_y2, draw_x3-draw_x2);
1466   2                      else
1467   2                              EG_Graphic_DrawHorizonLine(draw_x3, draw_y3, draw_x2-draw_x3);
1468   2              }
1469   1      }
1470          
1471          void EG_Graphic_DrawChar(unsigned int x,unsigned int y,char val){
1472   1          char tmp;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 25  

1473   1          int index;
1474   1          tmp=val&0xF0;
1475   1          tmp=tmp>>4;
1476   1          index=(tmp-2)*16;
1477   1          index+=val&0x0F;
1478   1          for(tmp=0;tmp<8;tmp++){
1479   2              EG_LCDSetByte(y+tmp,x,EG_SmallFont[index][tmp]);
1480   2          }
1481   1      }
1482          
1483          void EG_Graphic_DrawNotChar(unsigned int x,unsigned int y,char val){
1484   1          char tmp;
1485   1          int index;
1486   1          tmp=val&0xF0;
1487   1          tmp=tmp>>4;
1488   1          index=(tmp-2)*16;
1489   1          index+=val&0x0F;
1490   1          for(tmp=0;tmp<8;tmp++){
1491   2              EG_LCDSetByte(y+tmp,x,~EG_SmallFont[index][tmp]);
1492   2          }
1493   1      }
1494          
1495          void EG_Graphic_DrawString(unsigned int x,unsigned int y,char* string){
1496   1          unsigned int n=0;
1497   1          while(string[n]!='\0'){
1498   2              EG_Graphic_DrawChar(x,y,string[n]);
1499   2              x=x+8;
1500   2              n++;
1501   2          }
1502   1      }
1503          
1504          void EG_Graphic_DrawNotString(unsigned int x,unsigned int y,char* string){
1505   1          unsigned int n=0;
1506   1          while(string[n]!='\0'){
1507   2              EG_Graphic_DrawNotChar(x,y,string[n]);
1508   2              x=x+8;
1509   2              n++;
1510   2          }
1511   1      }
1512          
1513          void EG_Graphic_DrawConstString(unsigned int x,unsigned int y,char* string,unsigned char size){
1514   1          unsigned char n=0;
1515   1          for(;n<size;n++){
1516   2              EG_Graphic_DrawChar(x,y,string[n]);
1517   2              x=x+8;
1518   2          }
1519   1      }
1520          
1521          #ifndef EG_NO_BITMAP
              void EG_Graphic_DrawBitmap(unsigned int x,unsigned int y,EBitmap* pBitmap){
                      unsigned char mask;
                      unsigned char count;
                      unsigned char* tempp=pBitmap->m_pImageBuffer;
                      if(tempp==NULL)
                              return; 
                      for(unsigned int m=0;m<pBitmap->m_uHeight;m++){
                              for(unsigned int n=0;n<pBitmap->m_uWidth;n++){
                                      mask=0x80;
                                      for(count=0;count<8;count++){
                                              if(*tempp&mask){
                                                      EG_Graphic_DrawBlackPoint(x+n,y+(m<<3)+count);
                                              }else{
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 26  

                                                      EG_Graphic_DrawWhitePoint(x+n,y+(m<<3)+count);
                                              }               
                                              mask=mask>>1;
                                      }       
                                      tempp++;
                              }
                      }               
              }
              #endif //EG_NO_BITMAP
1544          
1545          #ifndef EG_NO_FONT
              void EG_Graphic_DrawFontChar(unsigned int x,unsigned int y,char val,const EFont& font){
                  unsigned int temp1,temp2,tmp,n,index;
                      tmp=val&0xF0;
                      tmp=tmp>>4;
                      index=(tmp-2)*16;
                      index+=val&0x0F;
                  for(temp1=0;temp1<EG_FontHeight[font.m_cFontNumber];temp1++){
                              for(temp2=0;temp2<EG_FontWidth[font.m_cFontNumber];temp2++){
                                      tmp=0x01;
                                      tmp=tmp<<temp2;
                                      if(font.m_cFontNumber==0){
                                              n=EG_SmallFont[index][temp1];
                                      }else if(font.m_cFontNumber==1){
                                              n=EG_NormalFont[index][temp1];
                                      }else if(font.m_cFontNumber==2){
                                              n=EG_NormalCambriaFont[index][temp1];
                                      }else if(font.m_cFontNumber==3){
                                              n=EG_NormalBoldCambriaFont[index][temp1];
                                      }else{
                                              n=EG_NormalBoldFont[index][temp1];
                                      }
                                      if(n&tmp){
                                              if(font.m_cFontSize==1){
                                                      EG_LCDSetPixel(y+temp1,x+EG_FontWidth[font.m_cFontNumber]-1-temp2);
                                              }else if (font.m_cFontSize==2){
                                                      EG_LCDSetPixel(y+(temp1<<1),x+((EG_FontWidth[font.m_cFontNumber]-temp2)<<1)-1);         
                                                      EG_LCDSetPixel(y+(temp1<<1)+1,x+((EG_FontWidth[font.m_cFontNumber]-temp2)<<1));         
                                                      EG_LCDSetPixel(y+(temp1<<1)+1,x+((EG_FontWidth[font.m_cFontNumber]-temp2)<<1)-1);               
                                                      EG_LCDSetPixel(y+(temp1<<1),x+((EG_FontWidth[font.m_cFontNumber]-temp2)<<1));           
                                              }else{
                                                      EG_LCDSetPixel(y+temp1*3,x+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)-1);
                                                      EG_LCDSetPixel(y+temp1*3,x+((EG_FontWidth[font.m_cFontNumber]-temp2)*3));
                                                      EG_LCDSetPixel(y+temp1*3,x+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)+1);             
                                                      EG_LCDSetPixel(y+temp1*3+1,x+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)-1);
                                                      EG_LCDSetPixel(y+temp1*3+1,x+((EG_FontWidth[font.m_cFontNumber]-temp2)*3));
                                                      EG_LCDSetPixel(y+temp1*3+1,x+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)+1);           
                                                      EG_LCDSetPixel(y+temp1*3+2,x+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)-1);
                                                      EG_LCDSetPixel(y+temp1*3+2,x+((EG_FontWidth[font.m_cFontNumber]-temp2)*3));
                                                      EG_LCDSetPixel(y+temp1*3+2,x+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)+1);           
                                              }
                                      }
                              }
                  }
              }
              
              void EG_Graphic_DrawNotFontChar(unsigned int x,unsigned int y,char val,const EFont& font){
                  unsigned int temp1,temp2,tmp,n,index;
                      tmp=val&0xF0;
                      tmp=tmp>>4;
                      index=(tmp-2)*16;
                      index+=val&0x0F;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 27  

                  for(temp1=0;temp1<EG_FontHeight[font.m_cFontNumber];temp1++){
                              for(temp2=0;temp2<EG_FontWidth[font.m_cFontNumber];temp2++){
                                      tmp=0x01;
                                      tmp=tmp<<temp2;
                                      if(font.m_cFontNumber==0){
                                              n=EG_SmallFont[index][temp1];
                                      }else if(font.m_cFontNumber==1){
                                              n=EG_NormalFont[index][temp1];
                                      }else if(font.m_cFontNumber==2){
                                              n=EG_NormalCambriaFont[index][temp1];
                                      }else if(font.m_cFontNumber==3){
                                              n=EG_NormalBoldCambriaFont[index][temp1];
                                      }else{
                                              n=EG_NormalBoldFont[index][temp1];
                                      }
                                      if(!(n&tmp)){
                                              if(font.m_cFontSize==1){
                                                      EG_LCDSetPixel(y+temp1,x+EG_FontWidth[font.m_cFontNumber]-1-temp2);
                                              }else if (font.m_cFontSize==2){
                                                      EG_LCDSetPixel(y+(temp1<<1),x+((EG_FontWidth[font.m_cFontNumber]-temp2)<<1)-1);         
                                                      EG_LCDSetPixel(y+(temp1<<1)+1,x+((EG_FontWidth[font.m_cFontNumber]-temp2)<<1));         
                                                      EG_LCDSetPixel(y+(temp1<<1)+1,x+((EG_FontWidth[font.m_cFontNumber]-temp2)<<1)-1);               
                                                      EG_LCDSetPixel(y+(temp1<<1),x+((EG_FontWidth[font.m_cFontNumber]-temp2)<<1));           
                                              }else{
                                                      EG_LCDSetPixel(y+temp1*3,x+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)-1);
                                                      EG_LCDSetPixel(y+temp1*3,x+((EG_FontWidth[font.m_cFontNumber]-temp2)*3));
                                                      EG_LCDSetPixel(y+temp1*3,x+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)+1);             
                                                      EG_LCDSetPixel(y+temp1*3+1,x+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)-1);
                                                      EG_LCDSetPixel(y+temp1*3+1,x+((EG_FontWidth[font.m_cFontNumber]-temp2)*3));
                                                      EG_LCDSetPixel(y+temp1*3+1,x+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)+1);           
                                                      EG_LCDSetPixel(y+temp1*3+2,x+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)-1);
                                                      EG_LCDSetPixel(y+temp1*3+2,x+((EG_FontWidth[font.m_cFontNumber]-temp2)*3));
                                                      EG_LCDSetPixel(y+temp1*3+2,x+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)+1);           
                                              }
                                      }
                              }
                  }
              }
              
              void EG_Graphic_DrawFontString(unsigned int x,unsigned int y,char* string,const EFont& font){
                  unsigned int n=0;
                  while(string[n]!='\0'){
                      EG_Graphic_DrawFontChar(x,y,string[n],font);
                      x=x+EG_FontWidth[font.m_cFontNumber]*font.m_cFontSize;
                      n++;
                  }
              }
              
              void EG_Graphic_DrawConstFontString(unsigned int x,unsigned int y,char* string,unsigned char size,const EF
             -ont& font){
                  unsigned char n=0;
                  for(;n<size;n++){
                      EG_Graphic_DrawFontChar(x,y,string[n],font);
                      x=x+EG_FontWidth[font.m_cFontNumber]*font.m_cFontSize;
                  }
              }
              
              void EG_Graphic_DrawNotFontString(unsigned int x,unsigned int y,char* string,const EFont& font){
                  unsigned int n=0;
                  while(string[n]!='\0'){
                      EG_Graphic_DrawNotFontChar(x,y,string[n],font);
                      x=x+EG_FontWidth[font.m_cFontNumber]*font.m_cFontSize;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 28  

                      n++;
                  }
              }
              #endif //EG_NO_FONT
1662          
1663          #else  //EG_RGB_COLOR
              
              void EG_Graphic_DrawPoint(const EPosition& pos,const EColor& color){
                      EG_Sim_Buffer[pos.m_uY][pos.m_uX]=color;
              }
              
              void EG_Graphic_DrawHorizonLine(const EPosition& pos,unsigned int length,const EColor& color){
                  unsigned int n=0;
                  for(;n<length;n++){
                              EG_Sim_Buffer[pos.m_uY][pos.m_uX+n]=color;
                  }
              }
              
              void EG_Graphic_DrawVerticalLine(const EPosition& pos,unsigned int length,const EColor& color){
                  unsigned int n=0;
                  for(;n<length;n++){
                              EG_Sim_Buffer[pos.m_uY+n][pos.m_uX]=color;
                  }
              }
              
              void EG_Graphic_DrawLine(const EPosition& pos0,const EPosition& pos1,const EColor& color,bool virtualLine)
             -{
                      int   dx;                                               // line x axie delta variable
                      int   dy;                               // line y axie delta variable
                      char    dx_sym;                                 // increase direaction of x axie    -1 or 1
                      char    dy_sym;                                 // increase direaction of y axie 
                      int   dx_x2;                                    // dx*2  accelarate variable
                      int   dy_x2;                                    // dy*2  accelarate variable
                      int   di;                                               //  decide variable
                      int count=0;
              
                      dx = pos1.m_uX-pos0.m_uX;                                               // delta between two points.
                      dy = pos1.m_uY-pos0.m_uY;
                      /* whether this is a horizonal or vertical line */
                      if(dx>0){
                              dx_sym = 1;                                     // dx>0 , dx_sym=1
                      }else{
                              if(dx<0){
                                      dx_sym = -1;                            // dx<0 , dx_sym=-1
                              }else{  // dx==0 vertical line
                                      EG_Graphic_DrawVerticalLine(pos0,pos1.m_uY-pos0.m_uY,color);
                                      return;
                              }
                      }
                      if(dy>0){                                                       // direction of y axie
                              dy_sym = 1;                                     //dy>0,dy_sym=1
                      }else{
                              if(dy<0){ 
                                      dy_sym = -1;                            //dy<0,dy_sym=-1
                              }else{  // dy==0, draw horizonal line
                                      EG_Graphic_DrawHorizonLine(pos0,pos1.m_uX-pos0.m_uX,color);
                                      return;
                              }
                      }
                      /*  abs( dx and dy )  */
                      dx = dx_sym * dx;
                      dy = dy_sym * dy;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 29  

                      dx_x2 = dx*2;
                      dy_x2 = dy*2;
              
                      EPosition pos;
                      pos=pos0;
                      /* using Bresenham to draw straight line */
                      if(dx>=dy){                                             //dx>=dy  use x axie as direction.
                              di = dy_x2 - dx;
                              while(pos.m_uX!=pos1.m_uX){
                                      if (virtualLine){
                                              if (count==3){
                                                      count=0;
                                              }else if(count==2){
                                                      count=3;
                                              }else{
                                                      count++;
                                                      EG_Graphic_DrawPoint(pos, color);       
                                              }
                                      }else{
                                              EG_Graphic_DrawPoint(pos, color);       
                                      }
                                      pos.m_uX += dx_sym;
                                      if(di<0){
                                              di += dy_x2;                    // dicision value of the next step
                                      }else{
                                              di += dy_x2 - dx_x2;
                                              pos.m_uY += dy_sym;
                                      }
                              }
                              EG_Graphic_DrawPoint(pos, color);// show the last point
                      }else{                                                          //dx<dy  use y axie as direction.
                          di = dx_x2 - dy;
                              while(pos.m_uY!=pos1.m_uY){
                                      if (virtualLine){
                                              if (count==3){
                                                      count=0;
                                              }else if(count==2){
                                                      count=3;
                                              }else{
                                                      count++;
                                                      EG_Graphic_DrawPoint(pos, color);       
                                              }
                                      }else{
                                              EG_Graphic_DrawPoint(pos, color);       
                                      }
                                      pos.m_uY += dy_sym;
                                      if(di<0){
                                              di += dx_x2;
                                      }else{
                                              di += dx_x2 - dy_x2;
                                              pos.m_uX += dx_sym;
                                      }
                              }
                              EG_Graphic_DrawPoint(pos, color);               // show the last point
                      } 
              }
              
              void EG_Graphic_DrawWidthLine(const EPosition& pos0,const EPosition& pos1,const EColor& color,unsigned cha
             -r lineWidth){
                      int   dx;                                               //delta value of x axie
                      int   dy;                               //delta value of y axie
                      char    dx_sym;                                 //increase direction along the x axie
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 30  

                      char    dy_sym;                                 //increase direction along the y axie
                      int   dx_x2;                                    //equal to 2 * dx
                      int   dy_x2;                                    //equal to 2 * dx
                      int   di;                                               //decide variable
                      int   wx, wy;                                   //line width
                      int   draw_a, draw_b;
                      EPosition pos,posA,posB;
                      posA=pos0;
                      posB=pos1;
              
                      //draw nothing, if width==0
                      if(lineWidth==0)
                         return;
                      //well, don't tell me width>50.....  if so, write a DrawStick function by yourself  :)
                      if(lineWidth>50)
                              lineWidth = 50;
                
                      dx = posB.m_uX-posA.m_uX;                       
                      dy = posB.m_uY-posA.m_uY; 
                      wx = lineWidth/2;
                      wy = lineWidth-wx-1;
              
                 /* set the increase direction along x axie*/
                      if(dx>0){
                              dx_sym = 1;                                     // dx>0, set dx_sym=1
                      }else{
                              if(dx<0){
                                      dx_sym = -1;                            // dx<0, set dx_sym=-1
                              }else{     /* dx==0,  it is a vertical line */
                                      wx = posA.m_uX-wx;
                                      if(wx<0)
                                              wx = 0;
                                      wy = posA.m_uX+wy;
                                      while(1){
                                              posA.m_uX = wx;
                                              EG_Graphic_DrawVerticalLine(posA,posB.m_uY-posA.m_uY,color);
                                              if(wx>=wy)
                                                      break;
                                              wx++;
                                      }
                              return;
                              }
                      }
                 /* set the increase direction along x axie*/
                      if(dy>0){
                              dy_sym = 1;                                     // dy>0, set dy_sym=1
                      }else{
                              if(dy<0){
                                      dy_sym = -1;                            // dy<0, set dy_sym=-1
                              }else{
                              /* dy==0  draw a horizonal line*/
                                      wx = posA.m_uY-wx;
                                      if(wx<0)
                                              wx = 0;
                                      wy = posA.m_uY+wy;         
                                      while(1){
                                              posA.m_uY = wx;
                                              EG_Graphic_DrawHorizonLine(posA,posB.m_uX-posA.m_uX,color);
                                              if(wx>=wy)
                                                      break;
                                              wx++;
                                      }
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 31  

                              return;
                              }
                      }
                      /*dx, dy = abs(dx,dy) */
                      dx = dx_sym * dx;
                      dy = dy_sym * dy;
                      dx_x2 = dx*2;
                      dy_x2 = dy*2;
                 
                      if(dx>=dy){
                              di = dy_x2 - dx;
                              while(posA.m_uX!=posB.m_uX){  
                                      draw_a = posA.m_uY-wx;
                                      if(draw_a<0)
                                              draw_a = 0;
                                      draw_b = posA.m_uY+wy;
                                      pos.m_uX=posA.m_uX;
                                      pos.m_uY=draw_a;
                                      EG_Graphic_DrawVerticalLine(pos,draw_b-draw_a,color);
                                      posA.m_uX += dx_sym;                            
                                      if(di<0){
                                              di += dy_x2;                    //get decide value of the next step
                                      }else{
                                              di += dy_x2 - dx_x2;
                                              posA.m_uY += dy_sym;
                                      }
                              }
                              draw_a = posA.m_uY-wx;
                              if(draw_a<0)
                                      draw_a = 0;
                              draw_b = posA.m_uY+wy;
                              pos.m_uX=posA.m_uX;
                              pos.m_uY=draw_a;
                              EG_Graphic_DrawVerticalLine(pos,draw_b-draw_a,color);
                      }else{
                              di = dx_x2 - dy;
                              while(posA.m_uY!=posB.m_uY){  
                                      draw_a =posA.m_uX-wx;
                                      if(draw_a<0)
                                              draw_a = 0;
                                      draw_b = posA.m_uX+wy;
                                      pos.m_uX=draw_a;
                                      pos.m_uY=posA.m_uY;
                                      EG_Graphic_DrawHorizonLine(pos,draw_b-draw_a,color);
                                      posA.m_uY += dy_sym;
                                      if(di<0){
                                              di += dx_x2;
                                      }else{
                                              di += dx_x2 - dy_x2;
                                              posA.m_uX += dx_sym;
                                      }
                              }
                              draw_a = posA.m_uX-wx;
                              if(draw_a<0)
                                      draw_a = 0;
                              draw_b = posA.m_uX+wy;
                              pos.m_uX=draw_a;
                              pos.m_uY=posA.m_uY;
                              EG_Graphic_DrawHorizonLine(pos,draw_b-draw_a,color);
                      }
              }
              
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 32  

              void EG_Graphic_DrawEmptyRectangle(const EPosition& pos,const ESize& size,const EColor& color){
                  unsigned int n;     
                      EPosition pos1,pos2;
                      pos1.m_uX=pos.m_uX+size.m_uWidth;
                      pos1.m_uY=pos.m_uY;
                      pos2.m_uX=pos.m_uX;
                      pos2.m_uY=pos.m_uY+size.m_uHeight;
                      for (n=0;n<size.m_uWidth;n++){
                              EG_Graphic_DrawVerticalLine(pos,size.m_uHeight,color);
                              EG_Graphic_DrawVerticalLine(pos1,size.m_uHeight,color);
                              EG_Graphic_DrawHorizonLine(pos,size.m_uWidth,color);
                              EG_Graphic_DrawHorizonLine(pos2,size.m_uWidth+1,color);         
                      }
              }
              
              void EG_Graphic_DrawFilledRectangle(const EPosition& pos,const ESize& size,const EColor& color){
                  unsigned int n;     
                      EPosition pos1;
                      pos1.m_uX=pos.m_uX;
                      for (n=0;n<size.m_uHeight;n++){
                              pos1.m_uY=pos.m_uY+n;
                              EG_Graphic_DrawHorizonLine(pos1,size.m_uWidth,color);   
                      }
              }
              
              void EG_Graphic_DrawEmptyCircle(const EPosition& center,unsigned int radius,const EColor& color){
                      int  draw_x0, draw_y0;                  //draw points
                      int  draw_x1, draw_y1;  
                      int  draw_x2, draw_y5;  
                      int  draw_x3, draw_y3;  
                      int  draw_x4, draw_y4;  
                      int  draw_x6, draw_y6;  
                      int  draw_x7, draw_y7;  
                      int draw_x5, draw_y2;   
                      int  xx, yy;                                    // circle control variable
                      int  di;                                                // decide variable
                      if(0==radius)
                              return;
              
                      /* calculate 8 special point(0、45、90、135、180、225、270degree) display them */
                      draw_x0 = draw_x1 = center.m_uX;
                      draw_y0 = draw_y1 = center.m_uY + radius;
                      if(draw_y0<EG_ROW)
                              EG_Sim_Buffer[draw_y0][draw_x0]=color;// 90degree
                      draw_x2 = draw_x3 = center.m_uX;
                      draw_y2 = draw_y3 = center.m_uY - radius;
                      if(draw_y2>=0)
                              EG_Sim_Buffer[draw_y2][draw_x2]=color;// 270degree
                      draw_x4 = draw_x6 = center.m_uX + radius;
                      draw_y4 = draw_y6 = center.m_uY;
                      if(draw_x4<EG_COLUMN)
                              EG_Sim_Buffer[draw_y4][draw_x4]=color;// 0degree
                      draw_x5 = draw_x7 = center.m_uX - radius;
                      draw_y5 = draw_y7 = center.m_uY;
                      if(draw_x5>=0)
                              EG_Sim_Buffer[draw_y5][draw_x5]=color;// 180degree
                      if(1==radius)   // if the radius is 1, finished.
                              return;                                 
                      /*using Bresenham */
                      di = 3 - 2*radius;      
                      xx = 0;
                      yy = radius;    
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 33  

                      while(xx<yy){
                              if(di<0){
                                      di += 4*xx + 6;       
                              }else{
                                      di += 4*(xx - yy) + 10;
                                      yy--;     
                                      draw_y0--;
                                      draw_y1--;
                                      draw_y2++;
                                      draw_y3++;
                                      draw_x4--;
                                      draw_x5++;
                                      draw_x6--;
                                      draw_x7++;              
                              }
                              xx++;   
                              draw_x0++;
                              draw_x1--;
                              draw_x2++;
                              draw_x3--;
                              draw_y4++;
                              draw_y5++;
                              draw_y6--;
                              draw_y7--;
                              /*judge current point in the avaible range*/
                              if( (draw_x0<=EG_COLUMN)&&(draw_y0>=0) ){
                                      EG_Sim_Buffer[draw_y0][draw_x0]=color;
                              }           
                              if( (draw_x1>=0)&&(draw_y1>=0) ){
                                      EG_Sim_Buffer[draw_y1][draw_x1]=color;
                              }
                              if( (draw_x2<=EG_COLUMN)&&(draw_y2<=EG_ROW) ){
                                      EG_Sim_Buffer[draw_y2][draw_x2]=color;
                              }
                              if( (draw_x3>=0)&&(draw_y3<=EG_ROW) ){ 
                                      EG_Sim_Buffer[draw_y3][draw_x3]=color;
                              }
                              if( (draw_x4<=EG_COLUMN)&&(draw_y4>=0) ){
                                      EG_Sim_Buffer[draw_y4][draw_x4]=color;
                              }
                              if( (draw_x5>=0)&&(draw_y5>=0) ){
                                      EG_Sim_Buffer[draw_y5][draw_x5]=color;
                              }
                              if( (draw_x6<=EG_COLUMN)&&(draw_y6<=EG_ROW) ){
                                      EG_Sim_Buffer[draw_y6][draw_x6]=color;
                              }
                              if( (draw_x7>=0)&&(draw_y7<=EG_ROW) ){
                                      EG_Sim_Buffer[draw_y7][draw_x7]=color;
                              }
                      }
              }
              
              void EG_Graphic_DrawFilledCircle(const EPosition& center,unsigned int radius,const EColor& color){
                      int  draw_x0, draw_y0;                  //draw points
                      int  draw_x1, draw_y1;  
                      int  draw_x2, draw_y2;  
                      int  draw_x3, draw_y3;  
                      int  draw_x4, draw_y4;  
                      int  draw_x5, draw_y5;  
                      int  draw_x6, draw_y6;  
                      int  draw_x7, draw_y7;  
                      int  fill_x0, fill_y0;                  // variable used to fill the circle
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 34  

                      int  fill_x1;
                      int  xx, yy;                                    //circle control variable
                      int  di;                                                // decide variable
                      EPosition pos;
                      if(0==radius)
                              return;
                      /* calculate 4 special point(0、90、180、270degree) display them */
                      draw_x0 = draw_x1 =center.m_uX;
                      draw_y0 = draw_y1 = center.m_uY + radius;
                      if(draw_y0<EG_ROW){
                              EG_Sim_Buffer[draw_y0][draw_x0]=color;// 90degree
                      }
                      draw_x2 = draw_x3 = center.m_uX;
                      draw_y2 = draw_y3 = center.m_uY - radius;
                      if(draw_y2>=0){ 
                              EG_Sim_Buffer[draw_y2][draw_x2]=color;// 270degree
                      }
                      draw_x4 = draw_x6 = center.m_uX + radius;
                      draw_y4 = draw_y6 = center.m_uY;
                      if(draw_x4<EG_COLUMN){
                              EG_Sim_Buffer[draw_y4][draw_x4]=color;// 0degree
                              fill_x1 = draw_x4;
                      }else{
                              fill_x1 = EG_COLUMN;
                      }
                      fill_y0 = center.m_uY;                  // set the fill line start point fill_y0
                      fill_x0 = center.m_uX - radius;                                         // set the fill line start point fill_x0
                      if(fill_x0<0)
                              fill_x0 = 0;
                      pos.m_uX=fill_x0;
                      pos.m_uY=fill_y0;
                      EG_Graphic_DrawHorizonLine(pos, fill_x1-fill_x0, color);
                      draw_x5 = draw_x7 = center.m_uX - radius;
                      draw_y5 = draw_y7 = center.m_uY;
                      if(draw_x5>=0){
                              EG_Sim_Buffer[draw_y5][draw_x5]=color;// 180degree
                      }
                      if(1==radius) // if the radius is 1, finished.
                              return;
                      /*using Bresenham */
                      di = 3 - 2*radius;              
                      xx = 0;
                      yy = radius;
                      while(xx<yy){
                                      if(di<0){
                                              di += 4*xx + 6;
                                      }else{
                                              di += 4*(xx - yy) + 10;
                                              yy--;     
                                              draw_y0--;
                                              draw_y1--;
                                              draw_y2++;
                                              draw_y3++;
                                              draw_x4--;
                                              draw_x5++;
                                              draw_x6--;
                                              draw_x7++;               
                                      }
                                      xx++;   
                                      draw_x0++;
                                      draw_x1--;
                                      draw_x2++;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 35  

                                      draw_x3--;
                                      draw_y4++;
                                      draw_y5++;
                                      draw_y6--;
                                      draw_y7--;
                                      /*judge current point in the avaible range*/
                                      if( (draw_x0<=EG_COLUMN)&&(draw_y0>=0) ){
                                              EG_Sim_Buffer[draw_y0][draw_x0]=color;
                                      }           
                                      if( (draw_x1>=0)&&(draw_y1>=0) ){
                                              EG_Sim_Buffer[draw_y1][draw_x1]=color;
                                      }
                                      if(draw_x1>=0){  /* set the start point of fill line fill_x0 */
                                              fill_x0 = draw_x1;
                                              fill_y0 = draw_y1;
                                              if(fill_y0>EG_ROW)
                                                      fill_y0 = EG_ROW;
                                              if(fill_y0<0)
                                                      fill_y0 = 0; 
                                              fill_x1 = center.m_uX*2 - draw_x1;              /* set the end point of fill line fill_x1 */                                    
                                              if(fill_x1>EG_COLUMN)
                                                      fill_x1 = EG_COLUMN;
                                              EG_Graphic_DrawHorizonLine(EPosition(fill_x0, fill_y0), fill_x1-fill_x0, color);
                                      }
                                      if( (draw_x2<=EG_COLUMN)&&(draw_y2<=EG_ROW) ){
                                              EG_Sim_Buffer[draw_y2][draw_x2]=color;
                                      }
                                      if( (draw_x3>=0)&&(draw_y3<=EG_ROW)){
                                              EG_Sim_Buffer[draw_y3][draw_x3]=color;
                                      }
                                      if(draw_x3>=0){         
                                              fill_x0 = draw_x3;/* set the start point of fill line fill_x0 */
                                              fill_y0 = draw_y3;/* set the start point of fill line fill_y0 */
                                      if(fill_y0>EG_ROW)
                                              fill_y0 =EG_ROW;
                                      if(fill_y0<0)
                                              fill_y0 = 0;
                                      fill_x1 = center.m_uX*2 - draw_x3;              /*  set the end point of fill line fill_x1 */                   
                                      if(fill_x1>EG_COLUMN)
                                              fill_x1 = EG_COLUMN;
                                      EG_Graphic_DrawHorizonLine(EPosition(fill_x0, fill_y0), fill_x1-fill_x0, color);
                              }
                              if( (draw_x4<=EG_COLUMN)&&(draw_y4>=0) ){
                                      EG_Sim_Buffer[draw_y4][draw_x4]=color;
                              }
                              if( (draw_x5>=0)&&(draw_y5>=0) ){
                                      EG_Sim_Buffer[draw_y5][draw_x5]=color;
                              }
                              if(draw_x5>=0)  {
                                      fill_x0 = draw_x5;/* set the start point of fill line fill_x0 */
                                      fill_y0 = draw_y5;      /* set the start point of fill line fill_y0 */
                                      if(fill_y0>EG_ROW)
                                              fill_y0 = EG_ROW;
                                      if(fill_y0<0)
                                              fill_y0 = 0;                                                    
                                      fill_x1 = center.m_uX*2 - draw_x5;/* set the end point of fill line fill_x1 */                                  
                                      if(fill_x1>EG_COLUMN)
                                              fill_x1 =EG_COLUMN;
                                      EG_Graphic_DrawHorizonLine(EPosition(fill_x0, fill_y0), fill_x1-fill_x0, color);
                              }
                              if( (draw_x6<=EG_COLUMN)&&(draw_y6<=EG_ROW) ){
                                      EG_Sim_Buffer[draw_y6][draw_x6]=color;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 36  

                              }
                              if( (draw_x7>=0)&&(draw_y7<=EG_ROW) ){
                                      EG_Sim_Buffer[draw_y7][draw_x7]=color;
                              }
                              if(draw_x7>=0)  {
                                      fill_x0 = draw_x7;/* set the start point of fill line fill_x0 */
                                      fill_y0 = draw_y7;/* set the start point of fill line fill_y0 */
                                      if(fill_y0>EG_ROW)
                                              fill_y0 = EG_ROW;
                                      if(fill_y0<0)
                                              fill_y0 = 0;    
                                      fill_x1 = center.m_uX*2 - draw_x7;              /* set the end point of fill line fill_x1 */                            
                                      if(fill_x1>EG_COLUMN)
                                              fill_x1 =EG_COLUMN;
                                      EG_Graphic_DrawHorizonLine(EPosition(fill_x0, fill_y0), fill_x1-fill_x0, color);
                              }
                      }
              }
              
              void EG_Graphic_DrawQuarterArc(const EPosition& center,unsigned int radius,const EColor& color,unsigned ch
             -ar angle){
                      int  draw_x, draw_y;
                      int  op_x, op_y;
                      int  op_2rr= 2*radius*radius;
                      EPosition pos;
              
                      if(radius==0)
                              return;
                      switch(angle){
                              case  1:
                                      draw_x = center.m_uX+radius;
                                      draw_y = center.m_uY;
                                      op_x = radius;
                                      op_y = 0;
                                      while(1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);                                 
                                              /*calculate the next point*/
                                              op_y++;
                                              draw_y++;
                                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
                                                      op_x--;
                                                      draw_x--;
                                              }
                                              if(op_y>=op_x)
                                                      break;
                                      }
                          while(1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);                                 
                                              /*calculate the next point*/
                                              op_x--;
                                              draw_x--;
                                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0){
                                                      op_y++;
                                                      draw_y++;
                                              }
                                              if(op_x<=0){ 
                                                      pos.m_uX=draw_x;
                                                      pos.m_uY=draw_y;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 37  

                                                      EG_Graphic_DrawPoint(pos,color);                                 
                                                      break;
                                              }
                                      }
                          break;                              
                              case  2:
                                      draw_x = center.m_uX-radius;
                                      draw_y = center.m_uY;
                                      op_x = radius;
                                      op_y = 0;
                                      while(1){               
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);                                 
                                              op_y++;
                                              draw_y++;
                                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
                                                      draw_x++;
                                              }
                                              if(op_y>=op_x)
                                                      break;
                                      }
                                      while(1){                               
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);                                 
                                              op_x--;
                                              draw_x++;
                                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0){
                                                      op_y++;
                                                      draw_y++;
                                              }
                                              if(op_x<=0){
                                                      pos.m_uX=draw_x;
                                                      pos.m_uY=draw_y;
                                                      EG_Graphic_DrawPoint(pos,color);                                 
                                                      break;
                                              }
                                      }
                                      break;
                              case  3:
                                      draw_x = center.m_uX-radius;
                                      draw_y = center.m_uY;
                                      op_x = radius;
                                      op_y = 0;
                                      while(1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);                                 
                                              op_y++;
                                              draw_y--;
                                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
                                                      op_x--;
                                                      draw_x++;
                                              }
                                              if(op_y>=op_x)
                                                      break;
                                      }
                                      while(1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);                                 
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 38  

                                              op_x--;
                                              draw_x++;
                                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0){
                                                      op_y++;
                                                      draw_y--;
                                              }
                                              if(op_x<=0){                                    
                                                      pos.m_uX=draw_x;
                                                      pos.m_uY=draw_y;
                                                      EG_Graphic_DrawPoint(pos,color);                                 
                                                      break;
                                              }
                                      }
                                      break;
                              case  4:
                                      draw_x = center.m_uX+radius;
                                      draw_y = center.m_uY;
                                      op_x = radius;
                                      op_y = 0;
                                      while(1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);                                 
                                              op_y++;
                                              draw_y--;
                                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
                                                      op_x--;
                                                      draw_x--;
                                              }
                                              if(op_y>=op_x)
                                                      break;
                                      }
                                      while(1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);                                 
                                              op_x--;
                                              draw_x--;
                                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0){
                                                      op_y++;
                                                      draw_y--;
                                              }
                                              if(op_x<=0){
                                                      pos.m_uX=draw_x;
                                                      pos.m_uY=draw_y;
                                                      EG_Graphic_DrawPoint(pos,color);                                 
                                                      break;
                                              }
                                      }
                                      break;
                              default:
                                      break;
                      }
              }
              
              void EG_Graphic_DrawArc(const EPosition& center,unsigned int radius,const EColor& color,unsigned int start
             -Angle,unsigned int endAngle){
                      int  draw_x, draw_y;                                    //draw coordinate
                      int  op_x, op_y;                                                //operation coordinate
                      int  op_2rr=2*radius*radius;            
                      int  pno_angle= 0;                              
                      char  draw_on;                  //on=1,  draw point
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 39  

                      EPosition pos;
              
                      if(radius==0)
                              return;                                 
                      if(startAngle==endAngle)  //avoid the same angle,which may cause dead loop
                              return;                 
                      if((startAngle>=360)|| (endAngle>=360))
                              return;
                      /*arc points of 45 degree*/       
                      op_x = radius;
                      op_y = 0;
                      while(1){
                              pno_angle++;                                                    
                              /*calculate the next point*/
                              op_y++;
                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
                                      op_x--;
                              }
                              if(op_y>=op_x) 
                                      break;
                      }
                      draw_on = 0;                                                            //do not draw the point at the beginning
                      /* set the start point */
                      if(endAngle>startAngle)
                              draw_on = 1;
                      startAngle = (360-startAngle)*pno_angle/45;
                      endAngle = (360-endAngle)*pno_angle/45;
                      if(startAngle==0)
                              startAngle=1;
                      if(endAngle==0)
                              endAngle=1;
              
                      /*draw the arc,clockwise rotation*/
                      pno_angle = 0;
                      draw_x = center.m_uX+radius;
                      draw_y = center.m_uY;         
                      op_x = radius;
                      op_y = 0;
                      while(1){ 
                              op_y++;
                              draw_y--;
                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
                                      op_x--;
                                      draw_x--;
                              }
                              if(draw_on==1){
                                      pos.m_uX=draw_x;
                                      pos.m_uY=draw_y;
                                      EG_Graphic_DrawPoint(pos,color);
                              }
                              pno_angle++;
                              if((pno_angle==startAngle)||(pno_angle==endAngle)){
                                      draw_on =1-draw_on;
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                              } 
                              if(op_y>=op_x){
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 40  

                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      break;
                              }
                      }
                      while(1){
                              op_x--;
                              draw_x--;
                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0){
                                      op_y++;
                                      draw_y--;
                              }
                              if(draw_on==1){
                                      pos.m_uX=draw_x;
                                      pos.m_uY=draw_y;
                                      EG_Graphic_DrawPoint(pos,color);
                              }
                              pno_angle++;
                              if((pno_angle==startAngle)||(pno_angle==endAngle)){                     //toggle the draw_on,if it is the start or end ang
             -le
                                      draw_on = 1-draw_on;
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                              } 
                              if(op_x<=0){
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      break;
                              }
                      }
                      /*draw clockwise, from 269 degree*/
                      draw_y = center.m_uY-radius;
                      draw_x = center.m_uX;         
                      op_y = radius;
                      op_x = 0;
                      while(1){
                              op_x++;
                              draw_x--;
                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_y +1)>0){
                                      op_y--;
                                      draw_y++;
                              }
                              if(draw_on==1){
                                      pos.m_uX=draw_x;
                                      pos.m_uY=draw_y;
                                      EG_Graphic_DrawPoint(pos,color);
                              }
                              pno_angle++;
                              if( (pno_angle==startAngle)||(pno_angle==endAngle)){
                                      draw_on = 1-draw_on;
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 41  

                              }
                              if(op_x>=op_y){
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                              break;
                              }
                      }
                      while(1){
                              op_y--;
                              draw_y++;
                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_x +1)<=0){
                                      op_x++;
                                      draw_x--;
                              }
                              if(draw_on==1){
                                      pos.m_uX=draw_x;
                                      pos.m_uY=draw_y;
                                      EG_Graphic_DrawPoint(pos,color);
                              }
                              pno_angle++;
                              if((pno_angle==startAngle)||(pno_angle==endAngle)){
                                      draw_on = 1-draw_on;
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                              }
                              if(op_y<=0){
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      break;
                              }
                      }
                      /*draw clockwise, from 179 degree*/
                      draw_x = center.m_uX-radius;
                      draw_y = center.m_uY;         
                      op_x = radius;
                      op_y = 0;
                      while(1){
                              op_y++;
                              draw_y++;
                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
                                      op_x--;
                                      draw_x++;
                              }
                              if(draw_on==1){
                                      pos.m_uX=draw_x;
                                      pos.m_uY=draw_y;
                                      EG_Graphic_DrawPoint(pos,color);
                              }
                              pno_angle++;
                              if((pno_angle==startAngle)||(pno_angle==endAngle)){
                                      draw_on = 1-draw_on;
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 42  

                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                              } 
                              if(op_y>=op_x){
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      break;
                              }
                      }
                      while(1){
                              op_x--;
                              draw_x++;
                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0){
                                      op_y++;
                                      draw_y++;
                              }
                              if(draw_on==1){
                                      pos.m_uX=draw_x;
                                      pos.m_uY=draw_y;
                                      EG_Graphic_DrawPoint(pos,color);
                              }
                              pno_angle++;
                              if((pno_angle==startAngle)||(pno_angle==endAngle)){
                                      draw_on = 1-draw_on;
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                              }
                              if(op_x<=0){
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      break;
                              }
                      }
                      /*draw clockwise, from 89 degree*/
                      draw_y = center.m_uY+radius;
                      draw_x = center.m_uX;         
                      op_y = radius;
                      op_x = 0;
                      while(1){
                              op_x++;
                              draw_x++;
                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_y +1)>0){
                                      op_y--;
                                      draw_y--;
                              }
                              if(draw_on==1){
                                      pos.m_uX=draw_x;
                                      pos.m_uY=draw_y;
                                      EG_Graphic_DrawPoint(pos,color);
                              }
                              pno_angle++;
                              if((pno_angle==startAngle)||(pno_angle==endAngle)){
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 43  

                                      draw_on = 1-draw_on;
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                              }
                              if(op_x>=op_y){
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      break;
                              }
                      }
                      while(1){
                              op_y--;
                              draw_y--;
                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_x +1)<=0){
                                      op_x++;
                                      draw_x++;
                              }
                              if(draw_on==1){
                                      pos.m_uX=draw_x;
                                      pos.m_uY=draw_y;
                                      EG_Graphic_DrawPoint(pos,color);
                              }
                              pno_angle++;
                              if((pno_angle==startAngle)||(pno_angle==endAngle)){
                                      draw_on = 1-draw_on;
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                              } 
                              if(op_y<=0){
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      break;
                              }
                      }
              }
              
              void EG_Graphic_DrawPieSlice(const EPosition& center,unsigned int radius,const EColor& color,unsigned int 
             -startAngle,unsigned int endAngle){
                      int  draw_x, draw_y;                                    //draw coordinate
                      int  op_x, op_y;                                                //operation coordinate
                      int  op_2rr=2*radius*radius;            
                      int  pno_angle= 0;                              
                      char  draw_on;                  //on=1,  draw point
                      EPosition pos;
              
                      if(radius==0)
                              return;                                 
                      if(startAngle==endAngle)  //avoid the same angle,which may cause dead loop
                              return;                 
                      if((startAngle>=360)|| (endAngle>=360))
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 44  

                              return;
                      /*arc points of 45 degree*/       
                      op_x = radius;
                      op_y = 0;
                      while(1){
                              pno_angle++;                                                    
                              /*calculate the next point*/
                              op_y++;
                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
                                      op_x--;
                              }
                              if(op_y>=op_x) 
                                      break;
                      }
                      draw_on = 0;                                                            //do not draw the point at the beginning
                      /* set the start point */
                      if(endAngle>startAngle)
                              draw_on = 1;
                      startAngle = (360-startAngle)*pno_angle/45;
                      endAngle = (360-endAngle)*pno_angle/45;
                      if(startAngle==0)
                              startAngle=1;
                      if(endAngle==0)
                              endAngle=1;
              
                      /*draw the arc,clockwise rotation*/
                      pno_angle = 0;
                      draw_x = center.m_uX+radius;
                      draw_y = center.m_uY;         
                      op_x = radius;
                      op_y = 0;
                      while(1){ 
                              op_y++;
                              draw_y--;
                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
                                      op_x--;
                                      draw_x--;
                              }
                              if(draw_on==1){
                                      pos.m_uX=draw_x;
                                      pos.m_uY=draw_y;
                                      EG_Graphic_DrawPoint(pos,color);
                              }
                              pno_angle++;
                              if((pno_angle==startAngle)||(pno_angle==endAngle)){
                                      draw_on =1-draw_on;
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      EG_Graphic_DrawLine(center,pos,color,false);
                              } 
                              if(op_y>=op_x){
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      break;
                              }
                      }
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 45  

                      while(1){
                              op_x--;
                              draw_x--;
                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0){
                                      op_y++;
                                      draw_y--;
                              }
                              if(draw_on==1){
                                      pos.m_uX=draw_x;
                                      pos.m_uY=draw_y;
                                      EG_Graphic_DrawPoint(pos,color);
                              }
                              pno_angle++;
                              if((pno_angle==startAngle)||(pno_angle==endAngle)){                     //toggle the draw_on,if it is the start or end ang
             -le
                                      draw_on = 1-draw_on;
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      EG_Graphic_DrawLine(center,pos,color,false);
                              } 
                              if(op_x<=0){
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      break;
                              }
                      }
                      /*draw clockwise, from 269 degree*/
                      draw_y = center.m_uY-radius;
                      draw_x = center.m_uX;         
                      op_y = radius;
                      op_x = 0;
                      while(1){
                              op_x++;
                              draw_x--;
                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_y +1)>0){
                                      op_y--;
                                      draw_y++;
                              }
                              if(draw_on==1){
                                      pos.m_uX=draw_x;
                                      pos.m_uY=draw_y;
                                      EG_Graphic_DrawPoint(pos,color);
                              }
                              pno_angle++;
                              if( (pno_angle==startAngle)||(pno_angle==endAngle)){
                                      draw_on = 1-draw_on;
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      EG_Graphic_DrawLine(center,pos,color,false);
                              }
                              if(op_x>=op_y){
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 46  

                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                              break;
                              }
                      }
                      while(1){
                              op_y--;
                              draw_y++;
                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_x +1)<=0){
                                      op_x++;
                                      draw_x--;
                              }
                              if(draw_on==1){
                                      pos.m_uX=draw_x;
                                      pos.m_uY=draw_y;
                                      EG_Graphic_DrawPoint(pos,color);
                              }
                              pno_angle++;
                              if((pno_angle==startAngle)||(pno_angle==endAngle)){
                                      draw_on = 1-draw_on;
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      EG_Graphic_DrawLine(center,pos,color,false);
                              }
                              if(op_y<=0){
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      break;
                              }
                      }
                      /*draw clockwise, from 179 degree*/
                      draw_x = center.m_uX-radius;
                      draw_y = center.m_uY;         
                      op_x = radius;
                      op_y = 0;
                      while(1){
                              op_y++;
                              draw_y++;
                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_x +1)>0){
                                      op_x--;
                                      draw_x++;
                              }
                              if(draw_on==1){
                                      pos.m_uX=draw_x;
                                      pos.m_uY=draw_y;
                                      EG_Graphic_DrawPoint(pos,color);
                              }
                              pno_angle++;
                              if((pno_angle==startAngle)||(pno_angle==endAngle)){
                                      draw_on = 1-draw_on;
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 47  

                                      EG_Graphic_DrawLine(center,pos,color,false);
                              } 
                              if(op_y>=op_x){
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      break;
                              }
                      }
                      while(1){
                              op_x--;
                              draw_x++;
                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_y +1)<=0){
                                      op_y++;
                                      draw_y++;
                              }
                              if(draw_on==1){
                                      pos.m_uX=draw_x;
                                      pos.m_uY=draw_y;
                                      EG_Graphic_DrawPoint(pos,color);
                              }
                              pno_angle++;
                              if((pno_angle==startAngle)||(pno_angle==endAngle)){
                                      draw_on = 1-draw_on;
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      EG_Graphic_DrawLine(center,pos,color,false);
                              }
                              if(op_x<=0){
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      break;
                              }
                      }
                      /*draw clockwise, from 89 degree*/
                      draw_y = center.m_uY+radius;
                      draw_x = center.m_uX;         
                      op_y = radius;
                      op_x = 0;
                      while(1){
                              op_x++;
                              draw_x++;
                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr - 2*op_y +1)>0){
                                      op_y--;
                                      draw_y--;
                              }
                              if(draw_on==1){
                                      pos.m_uX=draw_x;
                                      pos.m_uY=draw_y;
                                      EG_Graphic_DrawPoint(pos,color);
                              }
                              pno_angle++;
                              if((pno_angle==startAngle)||(pno_angle==endAngle)){
                                      draw_on = 1-draw_on;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 48  

                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      EG_Graphic_DrawLine(center,pos,color,false);
                              }
                              if(op_x>=op_y){
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      break;
                              }
                      }
                      while(1){
                              op_y--;
                              draw_y--;
                              if((2*op_x*op_x + 2*op_y*op_y - op_2rr + 2*op_x +1)<=0){
                                      op_x++;
                                      draw_x++;
                              }
                              if(draw_on==1){
                                      pos.m_uX=draw_x;
                                      pos.m_uY=draw_y;
                                      EG_Graphic_DrawPoint(pos,color);
                              }
                              pno_angle++;
                              if((pno_angle==startAngle)||(pno_angle==endAngle)){
                                      draw_on = 1-draw_on;
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      EG_Graphic_DrawLine(center,pos,color,false);
                              } 
                              if(op_y<=0){
                                      if(draw_on==1){
                                              pos.m_uX=draw_x;
                                              pos.m_uY=draw_y;
                                              EG_Graphic_DrawPoint(pos,color);
                                      }
                                      break;
                              }
                      }
              }
              
              void EG_Graphic_DrawEmptyEllipse(unsigned int leftX,unsigned int topY,unsigned int rightX,unsigned int bot
             -tomY,const EColor& color){
                      int  draw_x0, draw_y0;          
                      int  draw_x1, draw_y1;
                      int  draw_x2, draw_y2;
                      int  draw_x3, draw_y3;
                      int  xx, yy;                            // draw control variable 
                      int  center_x, center_y;                //center of ellipse
                      int  radius_x, radius_y;                // radius along x and y axies
                      int  radius_xx, radius_yy;              
                      int  radius_xx2, radius_yy2;
                      int  di;                                                //decide variable
                      EPosition pos;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 49  

                      
                      if((leftX==rightX)||(topY==bottomY))
                              return;
                      /*calculate the center of ellipse*/
                      center_x = (leftX + rightX) >> 1;                       
                      center_y = (topY + bottomY) >> 1;
                      if(leftX > rightX){
                              radius_x = (leftX - rightX) >> 1;
                      }else{
                              radius_x = (rightX - leftX) >> 1;
                      }
                      if(topY > bottomY){
                              radius_y = (topY - bottomY) >> 1;
                      }else{
                              radius_y = (bottomY - topY) >> 1;
                      }
                      radius_xx = radius_x * radius_x;
                      radius_yy = radius_y * radius_y;
                      radius_xx2 = radius_xx<<1;
                      radius_yy2 = radius_yy<<1;
                      xx = 0;
                      yy = radius_y;
                      di = radius_yy2 + radius_xx - radius_xx2*radius_y ;
              
                      /*calculate the end point of ellipse to start drawing*/
                      draw_x0 = draw_x1 = draw_x2 = draw_x3 = center_x;
                      draw_y0 = draw_y1 = center_y + radius_y;
                      draw_y2 = draw_y3 = center_y - radius_y;
              
                      //end point on y axie
                      pos.m_uX=draw_x0;
                      pos.m_uY=draw_y0;
                      EG_Graphic_DrawPoint(pos,color);
                      pos.m_uX=draw_x2;
                      pos.m_uY=draw_y2;
                      EG_Graphic_DrawPoint(pos,color);
                      
                      while((radius_yy*xx)<(radius_xx*yy)){
                              if(di<0){
                                      di+= radius_yy2*(2*xx+3);
                              }else{
                                      di += radius_yy2*(2*xx+3) + 4*radius_xx - 4*radius_xx*yy;
                                      yy--;
                                      draw_y0--;
                                      draw_y1--;
                                      draw_y2++;
                                      draw_y3++;                               
                              }
                              xx ++;                                          // x axie ++
                              draw_x0++;
                              draw_x1--;
                              draw_x2++;
                              draw_x3--;
                              pos.m_uX=draw_x0;
                              pos.m_uY=draw_y0;
                              EG_Graphic_DrawPoint(pos,color);
                              pos.m_uX=draw_x1;
                              pos.m_uY=draw_y1;
                              EG_Graphic_DrawPoint(pos,color);
                              pos.m_uX=draw_x2;
                              pos.m_uY=draw_y2;
                              EG_Graphic_DrawPoint(pos,color);
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 50  

                              pos.m_uX=draw_x3;
                              pos.m_uY=draw_y3;
                              EG_Graphic_DrawPoint(pos,color);
                      }
                      di = radius_xx2*(yy-1)*(yy-1) + radius_yy2*xx*xx + radius_yy + radius_yy2*xx - radius_xx2*radius_yy;
                      while(yy>=0){
                              if(di<0){
                                      di+= radius_xx2*3 + 4*radius_yy*xx + 4*radius_yy - 2*radius_xx2*yy;
                                      xx ++;                                                  
                                      draw_x0++;
                                      draw_x1--;
                                      draw_x2++;
                                      draw_x3--;  
                              }else{
                                      di += radius_xx2*3 - 2*radius_xx2*yy;                                                    
                              }
                              yy--;
                              draw_y0--;
                              draw_y1--;
                              draw_y2++;
                              draw_y3++;      
                              pos.m_uX=draw_x0;
                              pos.m_uY=draw_y0;
                              EG_Graphic_DrawPoint(pos,color);
                              pos.m_uX=draw_x1;
                              pos.m_uY=draw_y1;
                              EG_Graphic_DrawPoint(pos,color);
                              pos.m_uX=draw_x2;
                              pos.m_uY=draw_y2;
                              EG_Graphic_DrawPoint(pos,color);
                              pos.m_uX=draw_x3;
                              pos.m_uY=draw_y3;
                              EG_Graphic_DrawPoint(pos,color);
                      }
              }
              
              void EG_Graphic_DrawFilledEllipse(unsigned int leftX,unsigned int topY,unsigned int rightX,unsigned int bo
             -ttomY,const EColor& color){
                      int  draw_x0, draw_y0;          
                      int  draw_x1, draw_y1;
                      int  draw_x2, draw_y2;
                      int  draw_x3, draw_y3;
                      int  xx, yy;                            // draw control variable 
                      int  center_x, center_y;                //center of ellipse
                      int  radius_x, radius_y;                // radius along x and y axies
                      int  radius_xx, radius_yy;              
                      int  radius_xx2, radius_yy2;
                      int  di;                                                //decide variable
                      EPosition pos;
                      
                      if((leftX==rightX)||(topY==bottomY))
                              return;
                      /*calculate the center of ellipse*/
                      center_x = (leftX + rightX) >> 1;                       
                      center_y = (topY + bottomY) >> 1;
                      if(leftX > rightX){
                              radius_x = (leftX - rightX) >> 1;
                      }else{
                              radius_x = (rightX - leftX) >> 1;
                      }
                      if(topY > bottomY){
                              radius_y = (topY - bottomY) >> 1;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 51  

                      }else{
                              radius_y = (bottomY - topY) >> 1;
                      }
                      radius_xx = radius_x * radius_x;
                      radius_yy = radius_y * radius_y;
                      radius_xx2 = radius_xx<<1;
                      radius_yy2 = radius_yy<<1;
                      xx = 0;
                      yy = radius_y;
                      di = radius_yy2 + radius_xx - radius_xx2*radius_y ;
              
                      /*calculate the end point of ellipse to start drawing*/
                      draw_x0 = draw_x1 = draw_x2 = draw_x3 = center_x;
                      draw_y0 = draw_y1 = center_y + radius_y;
                      draw_y2 = draw_y3 = center_y - radius_y;
              
                      //end point on y axie
                      pos.m_uX=draw_x0;
                      pos.m_uY=draw_y0;
                      EG_Graphic_DrawPoint(pos,color);
                      pos.m_uX=draw_x2;
                      pos.m_uY=draw_y2;
                      EG_Graphic_DrawPoint(pos,color);
              
                      while((radius_yy*xx)<(radius_xx*yy)){
                              if(di<0){
                                      di+= radius_yy2*(2*xx+3);
                              }else{
                                      di += radius_yy2*(2*xx+3) + 4*radius_xx - 4*radius_xx*yy;
                                      yy--;
                                      draw_y0--;
                                      draw_y1--;
                                      draw_y2++;
                                      draw_y3++;                               
                              }
                              xx ++;                                          // x axie ++
                              draw_x0++;
                              draw_x1--;
                              draw_x2++;
                              draw_x3--;
                              pos.m_uX=draw_x0;
                              pos.m_uY=draw_y0;
                              EG_Graphic_DrawPoint(pos,color);
                              pos.m_uX=draw_x1;
                              pos.m_uY=draw_y1;
                              EG_Graphic_DrawPoint(pos,color);
                              pos.m_uX=draw_x2;
                              pos.m_uY=draw_y2;
                              EG_Graphic_DrawPoint(pos,color);
                              pos.m_uX=draw_x3;
                              pos.m_uY=draw_y3;
                              EG_Graphic_DrawPoint(pos,color);
                              if(di>=0){
                                      if(draw_x1>draw_x0){
                                              pos.m_uX=draw_x0;
                                              pos.m_uY=draw_y0;
                                              EG_Graphic_DrawHorizonLine(pos, draw_x1-draw_x0,color);
                                      }else{
                                              pos.m_uX=draw_x1;
                                              pos.m_uY=draw_y1;
                                              EG_Graphic_DrawHorizonLine(pos, draw_x0-draw_x1,color);
                                      }
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 52  

                                      if(draw_x3>draw_x2){
                                              pos.m_uX=draw_x2;
                                              pos.m_uY=draw_y2;
                                              EG_Graphic_DrawHorizonLine(pos, draw_x3-draw_x2,color);
                                      }else{
                                              pos.m_uX=draw_x3;
                                              pos.m_uY=draw_y3;
                                              EG_Graphic_DrawHorizonLine(pos, draw_x2-draw_x3,color);
                                      }
                              }
                      }
                      di = radius_xx2*(yy-1)*(yy-1) + radius_yy2*xx*xx + radius_yy + radius_yy2*xx - radius_xx2*radius_yy;
                      while(yy>=0){
                              if(di<0){
                                      di+= radius_xx2*3 + 4*radius_yy*xx + 4*radius_yy - 2*radius_xx2*yy;
                                      xx ++;                                                  
                                      draw_x0++;
                                      draw_x1--;
                                      draw_x2++;
                                      draw_x3--;  
                              }else{
                                      di += radius_xx2*3 - 2*radius_xx2*yy;                                                    
                              }
                              yy--;
                              draw_y0--;
                              draw_y1--;
                              draw_y2++;
                              draw_y3++;      
                              pos.m_uX=draw_x0;
                              pos.m_uY=draw_y0;
                              EG_Graphic_DrawPoint(pos,color);
                              pos.m_uX=draw_x1;
                              pos.m_uY=draw_y1;
                              EG_Graphic_DrawPoint(pos,color);
                              pos.m_uX=draw_x2;
                              pos.m_uY=draw_y2;
                              EG_Graphic_DrawPoint(pos,color);
                              pos.m_uX=draw_x3;
                              pos.m_uY=draw_y3;
                              EG_Graphic_DrawPoint(pos,color);
                              //fill it ,since y axie has already changed
                              if(draw_x1>draw_x0){
                                      pos.m_uX=draw_x0;
                                      pos.m_uY=draw_y0;
                                      EG_Graphic_DrawHorizonLine(pos, draw_x1-draw_x0,color);
                              }else{
                                      pos.m_uX=draw_x1;
                                      pos.m_uY=draw_y1;
                                      EG_Graphic_DrawHorizonLine(pos, draw_x0-draw_x1,color);
                              }
                              if(draw_x3>draw_x2){
                                      pos.m_uX=draw_x2;
                                      pos.m_uY=draw_y2;
                                      EG_Graphic_DrawHorizonLine(pos, draw_x3-draw_x2,color);
                              }else{
                                      pos.m_uX=draw_x3;
                                      pos.m_uY=draw_y3;
                                      EG_Graphic_DrawHorizonLine(pos, draw_x2-draw_x3,color);
                              }       
                      }
              }
              
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 53  

              void EG_Graphic_DrawChar(const EPosition& pos,char val,const EColor& color){
                  char temp1,temp2,tmp,n;
                  int index;
                  tmp=val&0xF0;
                  tmp=tmp>>4;
                  index=(tmp-2)*16;
                  index+=val&0x0F;
                  for(temp1=0;temp1<8;temp1++){
                              for(temp2=0;temp2<8;temp2++){
                                      tmp=0x01;
                                      tmp=tmp<<temp2;
                                      n=EG_SmallFont[index][temp1];
                                      if(n&tmp){
                                              EG_Sim_Buffer[pos.m_uY+temp1][pos.m_uX+7-temp2]=color;                  
                                      }
                              }
                  }
              }
              
              void EG_Graphic_DrawNotChar(const EPosition& pos,char val,const EColor& color){
                  char temp1,temp2,tmp,n;
                  int index;
                  tmp=val&0xF0;
                  tmp=tmp>>4;
                  index=(tmp-2)*16;
                  index+=val&0x0F;
                  for(temp1=0;temp1<8;temp1++){
                              for(temp2=0;temp2<8;temp2++){
                                      tmp=0x01;
                                      tmp=tmp<<temp2;
                                      n=EG_SmallFont[index][temp1];
                                      if(!(n&tmp)){
                                              EG_Sim_Buffer[pos.m_uY+temp1][pos.m_uX+7-temp2]=color;                  
                                      }
                              }
                  }
              }
              
              void EG_Graphic_DrawString(const EPosition& pos,char* string,const EColor& color){
                  unsigned int n=0;
                      EPosition pos1;
                      pos1=pos;
                  while(string[n]!='\0'){
                              EG_Graphic_DrawChar(pos1,string[n],color);
                              pos1.m_uX=pos1.m_uX+8;
                      n++;
                  }
              }
              void EG_Graphic_DrawNotString(const EPosition& pos,char* string,const EColor& color){
                  unsigned int n=0;
                      EPosition pos1;
                      pos1=pos;
                  while(string[n]!='\0'){
                              EG_Graphic_DrawNotChar(pos1,string[n],color);
                              pos1.m_uX=pos1.m_uX+8;
                      n++;
                  }
              }
              
              void EG_Graphic_DrawConstString(const EPosition& pos,char* string,unsigned char size,const EColor& color){
                  unsigned char n=0;
                      EPosition pos1;
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 54  

                      pos1=pos;
                  for(;n<size;n++){
                              EG_Graphic_DrawChar(pos1,string[n],color);
                              pos1.m_uX=pos1.m_uX+8;
                  }
              }
              
              #ifndef EG_NO_BITMAP
              void EG_Graphic_DrawBitmap(const EPosition& pos,EBitmap* pBitmap){
                      EPosition curpos;
                      EColor temp;
                      unsigned char* tempp=pBitmap->m_pImageBuffer;
                      if(tempp==NULL)
                              return; 
                      for(unsigned int m=0;m<pBitmap->m_uHeight;m++){
                              for(unsigned int n=0;n<pBitmap->m_uWidth;n++){
                                      curpos.m_uX=pos.m_uX+n;
                                      curpos.m_uY=pos.m_uY+m;
                                      temp.m_cRed=*tempp++;
                                      temp.m_cGreen=*tempp++;
                                      temp.m_cBlue=*tempp++;
                                      EG_Graphic_DrawPoint(curpos,temp);              
                              }
                      }               
              }
              #endif //EG_NO_BITMAP
              
              #ifndef EG_NO_FONT
              void EG_Graphic_DrawFontChar(const EPosition& pos,char val,const EColor& color,const EFont& font){
                  unsigned int temp1,temp2,tmp,n,index;
                      tmp=val&0xF0;
                      tmp=tmp>>4;
                      index=(tmp-2)*16;
                      index+=val&0x0F;
                  for(temp1=0;temp1<EG_FontHeight[font.m_cFontNumber];temp1++){
                              for(temp2=0;temp2<EG_FontWidth[font.m_cFontNumber];temp2++){
                                      tmp=0x01;
                                      tmp=tmp<<temp2;
                                      if(font.m_cFontNumber==0){
                                              n=EG_SmallFont[index][temp1];
                                      }else if(font.m_cFontNumber==1){
                                              n=EG_NormalFont[index][temp1];
                                      }else if(font.m_cFontNumber==2){
                                              n=EG_NormalCambriaFont[index][temp1];
                                      }else if(font.m_cFontNumber==3){
                                              n=EG_NormalBoldCambriaFont[index][temp1];
                                      }else{
                                              n=EG_NormalBoldFont[index][temp1];
                                      }
                                      if(n&tmp){
                                              if(font.m_cFontSize==1){
                                                      EG_Sim_Buffer[pos.m_uY+temp1][pos.m_uX+EG_FontWidth[font.m_cFontNumber]-1-temp2]=color;                 
                                              }else if (font.m_cFontSize==2){
                                                      EG_Sim_Buffer[pos.m_uY+(temp1<<1)][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)<<1)-1]=color;             
             -        
                                                      EG_Sim_Buffer[pos.m_uY+(temp1<<1)+1][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)<<1)]=color;             
             -        
                                                      EG_Sim_Buffer[pos.m_uY+(temp1<<1)+1][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)<<1)-1]=color;
             -                        
                                                      EG_Sim_Buffer[pos.m_uY+(temp1<<1)][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)<<1)]=color;                       
                                              }else{
                                                      EG_Sim_Buffer[pos.m_uY+temp1*3][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)-1]=color;                 
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 55  

                                                      EG_Sim_Buffer[pos.m_uY+temp1*3][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)]=color;                   
                                                      EG_Sim_Buffer[pos.m_uY+temp1*3][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)+1]=color;                 
                                                      EG_Sim_Buffer[pos.m_uY+temp1*3+1][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)-1]=color;                       
                                                      EG_Sim_Buffer[pos.m_uY+temp1*3+1][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)]=color;                 
                                                      EG_Sim_Buffer[pos.m_uY+temp1*3+1][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)+1]=color;                       
                                                      EG_Sim_Buffer[pos.m_uY+temp1*3+2][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)-1]=color;                       
                                                      EG_Sim_Buffer[pos.m_uY+temp1*3+2][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)]=color;                 
                                                      EG_Sim_Buffer[pos.m_uY+temp1*3+2][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)+1]=color;                       
                                              }
                                      }
                              }
                  }
              }
              
              void EG_Graphic_DrawNotFontChar(const EPosition& pos,char val,const EColor& color,const EFont& font){
                  unsigned int temp1,temp2,tmp,n,index;
                      tmp=val&0xF0;
                      tmp=tmp>>4;
                      index=(tmp-2)*16;
                      index+=val&0x0F;
                  for(temp1=0;temp1<EG_FontHeight[font.m_cFontNumber];temp1++){
                              for(temp2=0;temp2<EG_FontWidth[font.m_cFontNumber];temp2++){
                                      tmp=0x01;
                                      tmp=tmp<<temp2;
                                      if(font.m_cFontNumber==0){
                                              n=EG_SmallFont[index][temp1];
                                      }else if(font.m_cFontNumber==1){
                                              n=EG_NormalFont[index][temp1];
                                      }else if(font.m_cFontNumber==2){
                                              n=EG_NormalCambriaFont[index][temp1];
                                      }else if(font.m_cFontNumber==3){
                                              n=EG_NormalBoldCambriaFont[index][temp1];
                                      }else{
                                              n=EG_NormalBoldFont[index][temp1];
                                      }
                                      if(!(n&tmp)){
                                              if(font.m_cFontSize==1){
                                                      EG_Sim_Buffer[pos.m_uY+temp1][pos.m_uX+EG_FontWidth[font.m_cFontNumber]-1-temp2]=color;                 
                                              }else if (font.m_cFontSize==2){
                                                      EG_Sim_Buffer[pos.m_uY+(temp1<<1)][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)<<1)-1]=color;             
             -        
                                                      EG_Sim_Buffer[pos.m_uY+(temp1<<1)+1][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)<<1)]=color;             
             -        
                                                      EG_Sim_Buffer[pos.m_uY+(temp1<<1)+1][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)<<1)-1]=color;
             -                        
                                                      EG_Sim_Buffer[pos.m_uY+(temp1<<1)][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)<<1)]=color;                       
                                              }else{
                                                      EG_Sim_Buffer[pos.m_uY+temp1*3][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)-1]=color;                 
                                                      EG_Sim_Buffer[pos.m_uY+temp1*3][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)]=color;                   
                                                      EG_Sim_Buffer[pos.m_uY+temp1*3][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)+1]=color;                 
                                                      EG_Sim_Buffer[pos.m_uY+temp1*3+1][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)-1]=color;                       
                                                      EG_Sim_Buffer[pos.m_uY+temp1*3+1][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)]=color;                 
                                                      EG_Sim_Buffer[pos.m_uY+temp1*3+1][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)+1]=color;                       
                                                      EG_Sim_Buffer[pos.m_uY+temp1*3+2][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)-1]=color;                       
                                                      EG_Sim_Buffer[pos.m_uY+temp1*3+2][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)]=color;                 
                                                      EG_Sim_Buffer[pos.m_uY+temp1*3+2][pos.m_uX+((EG_FontWidth[font.m_cFontNumber]-temp2)*3)+1]=color;                       
                                              }
                                      }
                              }
                  }
              }
              
C51 COMPILER V7.50   GRAPHICFUNC                                                           12/13/2009 14:49:11 PAGE 56  

              void EG_Graphic_DrawFontString(const EPosition& pos,char* string,const EColor& color,const EFont& font){
                  unsigned int n=0;
                      EPosition pos1;
                      pos1=pos;
                  while(string[n]!='\0'){
                              EG_Graphic_DrawFontChar(pos1,string[n],color,font);
                              pos1.m_uX=pos1.m_uX+EG_FontWidth[font.m_cFontNumber]*font.m_cFontSize;
                      n++;
                  }
              }
              
              void EG_Graphic_DrawConstFontString(const EPosition& pos,char* string,unsigned char size,const EColor& col
             -or,const EFont& font){
                  unsigned char n=0;
                      EPosition pos1;
                      pos1=pos;
                  for(;n<size;n++){
                              EG_Graphic_DrawFontChar(pos1,string[n],color,font);
                              pos1.m_uX=pos1.m_uX+EG_FontWidth[font.m_cFontNumber]*font.m_cFontSize;
                  }
              }
              
              void EG_Graphic_DrawNotFontString(const EPosition& pos,char* string,const EColor& color,const EFont& font)
             -{
                  unsigned int n=0;
                      EPosition pos1;
                      pos1=pos;
                  while(string[n]!='\0'){
                              EG_Graphic_DrawNotFontChar(pos1,string[n],color,font);
                              pos1.m_uX=pos1.m_uX+EG_FontWidth[font.m_cFontNumber]*font.m_cFontSize;
                      n++;
                  }
              }
              #endif //EG_NO_FONT
              
              #endif  //EG_RGB_COLOR
3413          
3414          
3415          
3416          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  19650    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    768     454
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
